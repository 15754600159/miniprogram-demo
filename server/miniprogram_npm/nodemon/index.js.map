{"version":3,"sources":["nodemon.js","monitor/index.js","monitor/run.js","utils/index.js","utils/clone.js","utils/merge.js","utils/bus.js","utils/log.js","utils/colour.js","monitor/watch.js","config/index.js","config/load.js","rules/index.js","rules/add.js","rules/parse.js","config/exec.js","config/defaults.js","version.js","config/command.js","monitor/match.js","monitor/signals.js","cli/index.js","cli/parse.js","help/index.js","spawn.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;AELA,AFMA;AELA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AIZA,ADGA;ADIA,AFMA,AIZA,ADGA;ADIA,AFMA,AIZA,ADGA;ADIA,AFMA,AIZA,ADGA,AENA;AHUA,AFMA,AIZA,ADGA,AENA;AHUA,AFMA,AIZA,ADGA,AENA;AHUA,AFMA,AMlBA,AFMA,ADGA,AENA;AHUA,AFMA,AMlBA,AFMA,ADGA,AENA;AHUA,AFMA,AMlBA,AFMA,ADGA,AENA;AHUA,AFMA,AMlBA,AFMA,ADGA,AIZA,AFMA;AHUA,AFMA,AMlBA,AFMA,ADGA,AIZA,AFMA;AHUA,AFMA,AMlBA,AFMA,ADGA,AIZA,AFMA;AHUA,AFMA,AMlBA,AFMA,AIZA,ALeA,AIZA,AFMA;AHUA,AFMA,AMlBA,AFMA,AIZA,ALeA,AIZA,AFMA;AHUA,AFMA,AMlBA,AFMA,AIZA,ALeA,AIZA,AFMA;AHUA,AOrBA,AT2BA,AMlBA,AFMA,AIZA,ALeA,AIZA,AFMA;AHUA,AOrBA,AT2BA,AMlBA,AFMA,AIZA,ALeA,AIZA,AFMA;AHUA,AOrBA,AT2BA,AMlBA,AFMA,AIZA,ALeA,AIZA,AFMA;AKdA,ARwBA,AOrBA,AT2BA,AMlBA,AFMA,AIZA,ALeA,AIZA,AFMA;AKdA,ARwBA,AOrBA,AT2BA,AMlBA,AFMA,AIZA,ALeA,AIZA,AFMA;AKdA,ARwBA,AOrBA,AT2BA,AMlBA,AFMA,AIZA,ALeA,AIZA,AFMA;AKdA,ACHA,AT2BA,AOrBA,AT2BA,AMlBA,AFMA,AIZA,ALeA,AIZA,AFMA;AKdA,ACHA,AT2BA,AOrBA,AT2BA,AMlBA,AFMA,AIZA,ALeA,AIZA,AFMA;AKdA,ACHA,AT2BA,AOrBA,AT2BA,AMlBA,AFMA,AIZA,ALeA,AIZA,AFMA;AKdA,ACHA,AT2BA,AOrBA,AT2BA,AYpCA,ANkBA,AFMA,AIZA,ALeA,AIZA,AFMA;AKdA,ACHA,AT2BA,AOrBA,AT2BA,AYpCA,ANkBA,AFMA,AIZA,ALeA,AIZA,AFMA;AKdA,ACHA,AT2BA,AOrBA,AT2BA,AYpCA,ANkBA,AFMA,AIZA,ALeA,AIZA,AFMA;AKdA,ACHA,AT2BA,AOrBA,AT2BA,AavCA,ADGA,ANkBA,AFMA,AIZA,ALeA,AIZA,AFMA;AKdA,ACHA,AT2BA,AOrBA,AT2BA,AavCA,ADGA,ANkBA,AFMA,AIZA,ALeA,AIZA,AFMA;AKdA,ACHA,AT2BA,AOrBA,AT2BA,AavCA,ADGA,ANkBA,AFMA,AIZA,ALeA,AIZA,AFMA;AKdA,ACHA,AT2BA,AOrBA,AT2BA,AavCA,ADGA,AENA,ARwBA,AFMA,AIZA,ALeA,AIZA,AFMA;AKdA,ACHA,AT2BA,AOrBA,AT2BA,AavCA,ADGA,AENA,ARwBA,AFMA,AIZA,ALeA,AIZA,AFMA;AKdA,ACHA,AT2BA,AOrBA,AT2BA,AavCA,ADGA,AENA,ARwBA,AFMA,AIZA,ALeA,AIZA,AFMA;AU7BA,ALeA,ACHA,AT2BA,AOrBA,AT2BA,AavCA,ADGA,AENA,ARwBA,AFMA,AIZA,ALeA,AIZA,AFMA;AU7BA,ALeA,ACHA,AT2BA,AOrBA,AT2BA,AavCA,ADGA,AENA,ARwBA,AFMA,AIZA,ALeA,AIZA,AFMA;AU7BA,ALeA,ACHA,AT2BA,AOrBA,AT2BA,AavCA,ADGA,AENA,ARwBA,AFMA,AIZA,ALeA,AIZA,AFMA;AWhCA,ADGA,ALeA,ACHA,AT2BA,AOrBA,AT2BA,AavCA,ADGA,AENA,ARwBA,AFMA,AIZA,ALeA,AIZA,AFMA;AWhCA,ADGA,ALeA,ACHA,AT2BA,AOrBA,AT2BA,AavCA,ADGA,AENA,ARwBA,AFMA,AIZA,ALeA,AIZA,AFMA;AWhCA,ADGA,ALeA,ACHA,AT2BA,AOrBA,AT2BA,AavCA,ADGA,AENA,ARwBA,AFMA,AIZA,ALeA,AIZA,AFMA;AWhCA,ADGA,ALeA,ACHA,AT2BA,AOrBA,AT2BA,AavCA,ADGA,AENA,ARwBA,AFMA,ADGA,AIZA,AFMA,AYpCA;ADIA,ADGA,ALeA,ACHA,AT2BA,AOrBA,AT2BA,AavCA,ADGA,AENA,ARwBA,AHSA,AIZA,AFMA,AYpCA;ADIA,ADGA,ALeA,ACHA,AT2BA,AOrBA,AT2BA,AavCA,ADGA,AENA,ARwBA,AHSA,AIZA,AFMA,AYpCA;ACFA,AFMA,ADGA,ALeA,ACHA,AT2BA,AOrBA,AT2BA,AavCA,ADGA,AENA,ARwBA,AHSA,AIZA,AFMA,AYpCA;ACFA,AFMA,ADGA,ALeA,ACHA,AT2BA,AOrBA,AT2BA,AavCA,ADGA,AENA,ARwBA,AHSA,AIZA,AFMA,AYpCA;ACFA,AFMA,ADGA,ALeA,ACHA,AT2BA,AOrBA,AT2BA,AavCA,ADGA,AENA,ARwBA,AHSA,AIZA,AFMA,AYpCA;ACFA,AFMA,ADGA,ALeA,ACHA,AQxBA,AjBmDA,AOrBA,AT2BA,AavCA,ADGA,AENA,ARwBA,AHSA,AIZA,AFMA,AYpCA;ACFA,AFMA,ADGA,ALeA,ACHA,AQxBA,AjBmDA,AOrBA,AT2BA,AavCA,ADGA,AENA,ARwBA,AHSA,AIZA,AFMA,AYpCA;ACFA,AFMA,ADGA,ALeA,ACHA,AQxBA,AjBmDA,AOrBA,AT2BA,AavCA,ADGA,AENA,ARwBA,AHSA,AIZA,AFMA,AYpCA;ACFA,AFMA,ADGA,ALeA,ACHA,AQxBA,AjBmDA,AkBtDA,AXiCA,AT2BA,AavCA,ADGA,AENA,ARwBA,AHSA,AIZA,AFMA,AYpCA;ACFA,AFMA,ADGA,ALeA,ACHA,AQxBA,AjBmDA,AkBtDA,AXiCA,AT2BA,AavCA,ADGA,AENA,ARwBA,AHSA,AIZA,AFMA,AYpCA;ACFA,AFMA,ADGA,ALeA,ACHA,AQxBA,AjBmDA,AkBtDA,AXiCA,AT2BA,AavCA,ADGA,AENA,ARwBA,AHSA,AIZA,AU9BA;AIXA,AHSA,AFMA,ADGA,ALeA,ACHA,AQxBA,AjBmDA,AkBtDA,AXiCA,AT2BA,AavCA,ADGA,AENA,AXiCA,AIZA,AU9BA;AIXA,AHSA,AFMA,ADGA,ALeA,ACHA,AQxBA,AjBmDA,AkBtDA,AXiCA,AT2BA,AavCA,ADGA,AENA,AXiCA,AIZA,AU9BA;AIXA,AHSA,AFMA,ADGA,ALeA,ACHA,AQxBA,AjBmDA,AkBtDA,AXiCA,AT2BA,AavCA,ADGA,AENA,AXiCA,AIZA,AU9BA;AIXA,ACHA,AJYA,AFMA,ADGA,ALeA,ACHA,AQxBA,AjBmDA,AkBtDA,AXiCA,AT2BA,AavCA,ADGA,AENA,AXiCA,AIZA,AU9BA;AIXA,ACHA,AJYA,AFMA,ADGA,ALeA,ACHA,AQxBA,AjBmDA,AkBtDA,AXiCA,AT2BA,AavCA,ADGA,AENA,AXiCA,AIZA,AU9BA;AIXA,ACHA,AJYA,AFMA,ADGA,ALeA,ACHA,AQxBA,AjBmDA,AkBtDA,AXiCA,AT2BA,AavCA,ADGA,AENA,AXiCA,AIZA,AU9BA;AIXA,ACHA,AJYA,AFMA,ADGA,ALeA,ACHA,AYpCA,AJYA,AjBmDA,AkBtDA,AXiCA,AT2BA,AavCA,ADGA,AENA,AXiCA,AIZA,AU9BA;AIXA,ACHA,AJYA,AFMA,ADGA,ALeA,ACHA,AYpCA,AJYA,AjBmDA,AkBtDA,AXiCA,AT2BA,AavCA,ADGA,AENA,AXiCA,AIZA,AU9BA;AIXA,ACHA,AJYA,AFMA,ADGA,ALeA,ACHA,AYpCA,AJYA,AjBmDA,AkBtDA,AXiCA,AT2BA,AavCA,ADGA,AENA,AXiCA,AIZA,AU9BA;AIXA,ACHA,AJYA,AFMA,ADGA,ALeA,ACHA,AYpCA,AJYA,AjBmDA,AkBtDA,AXiCA,AT2BA,AavCA,ADGA,AENA,AU9BA,ArB+DA,AIZA,AU9BA;AIXA,ACHA,AJYA,AFMA,ADGA,ALeA,ACHA,AYpCA,AJYA,AjBmDA,AkBtDA,AXiCA,AT2BA,AavCA,ADGA,AENA,AU9BA,ArB+DA,AIZA,AU9BA;AIXA,ACHA,AJYA,AFMA,ADGA,ALeA,ACHA,AYpCA,AJYA,AjBmDA,AkBtDA,AXiCA,AT2BA,AavCA,ADGA,AENA,AU9BA,ArB+DA,AIZA,AU9BA;AIXA,ACHA,AJYA,AFMA,ADGA,ALeA,ACHA,AYpCA,AJYA,AjBmDA,AkBtDA,AXiCA,AT2BA,AavCA,ADGA,AENA,AU9BA,ArB+DA,AIZA,AU9BA;AIXA,ACHA,AJYA,AFMA,ADGA,ALeA,ACHA,AYpCA,AJYA,AjBmDA,AkBtDA,AXiCA,AT2BA,AavCA,ADGA,AENA,AU9BA,ArB+DA,AIZA,AU9BA;AIXA,ACHA,AJYA,AHSA,ALeA,ACHA,AYpCA,AJYA,AjBmDA,AkBtDA,AXiCA,AT2BA,AavCA,ADGA,AENA,AU9BA,ArB+DA,AIZA,AU9BA;AIXA,ACHA,AJYA,AHSA,ALeA,ACHA,AYpCA,AJYA,AjBmDA,AkBtDA,AXiCA,AT2BA,AavCA,ADGA,AENA,AU9BA,ArB+DA,AIZA,AU9BA;AIXA,ACHA,AJYA,AHSA,ALeA,ACHA,AYpCA,AJYA,AjBmDA,AkBtDA,AXiCA,AT2BA,AavCA,ADGA,AENA,AU9BA,ArB+DA,AIZA,AU9BA;AIXA,ACHA,AJYA,AHSA,ALeA,ACHA,AYpCA,AJYA,AjBmDA,AkBtDA,AXiCA,AT2BA,AavCA,ADGA,AENA,AU9BA,ArB+DA,AIZA,AU9BA;AIXA,ACHA,AJYA,AHSA,ALeA,ACHA,AYpCA,AJYA,AjBmDA,AkBtDA,AXiCA,AT2BA,AavCA,ADGA,AENA,AU9BA,ArB+DA,AIZA,AU9BA;AIXA,ACHA,AJYA,AHSA,ALeA,ACHA,AYpCA,AJYA,AjBmDA,AkBtDA,AXiCA,AT2BA,AavCA,ADGA,AENA,AU9BA,ArB+DA,AIZA,AU9BA;AIXA,ACHA,AJYA,AHSA,ALeA,ACHA,AYpCA,AJYA,AjBmDA,AkBtDA,AXiCA,AT2BA,AavCA,ADGA,AENA,AU9BA,ArB+DA,AIZA,AU9BA;AIXA,ACHA,AJYA,AHSA,ALeA,ACHA,AYpCA,AJYA,AjBmDA,AkBtDA,AXiCA,AT2BA,AavCA,ADGA,AENA,AU9BA,ArB+DA,AIZA,AU9BA;AIXA,ACHA,AJYA,AHSA,ALeA,ACHA,AYpCA,AJYA,AjBmDA,AkBtDA,AXiCA,AT2BA,AavCA,ADGA,AENA,AU9BA,ArB+DA,AIZA,AU9BA;AIXA,ACHA,AJYA,AHSA,ALeA,ACHA,AYpCA,AJYA,AjBmDA,AkBtDA,AXiCA,AT2BA,AavCA,ADGA,AYpCA,ArB+DA,AIZA,AU9BA;AIXA,ACHA,AJYA,AHSA,ALeA,ACHA,AYpCA,AJYA,AjBmDA,AkBtDA,AXiCA,AT2BA,AavCA,ADGA,AYpCA,ArB+DA,AIZA,AU9BA;AIXA,ACHA,AJYA,AHSA,ALeA,ACHA,AYpCA,AJYA,AjBmDA,AkBtDA,AXiCA,AT2BA,AavCA,ADGA,AYpCA,ArB+DA,AIZA,AU9BA;AIXA,ACHA,AJYA,AHSA,ALeA,ACHA,AYpCA,AJYA,AjBmDA,AkBtDA,AXiCA,AT2BA,AavCA,AWjCA,ArB+DA,AIZA,AU9BA;AIXA,ACHA,AJYA,AHSA,ALeA,ACHA,AYpCA,AJYA,AjBmDA,AkBtDA,AXiCA,AT2BA,AavCA,AWjCA,ArB+DA,AIZA,AU9BA;AIXA,ACHA,AJYA,AHSA,ALeA,ACHA,AYpCA,AJYA,AjBmDA,AkBtDA,AXiCA,AT2BA,AavCA,AWjCA,ArB+DA,AIZA,AU9BA;AIXA,ACHA,AJYA,AHSA,ALeA,ACHA,AYpCA,AJYA,AjBmDA,AkBtDA,AXiCA,AT2BA,AavCA,AWjCA,ArB+DA,AIZA,AU9BA;AIXA,ACHA,AJYA,AHSA,ALeA,ACHA,AYpCA,AJYA,AjBmDA,AkBtDA,AXiCA,AT2BA,AavCA,AWjCA,ArB+DA,AIZA,AU9BA;AIXA,ACHA,AJYA,AHSA,ALeA,ACHA,AYpCA,AJYA,AjBmDA,AkBtDA,AXiCA,AT2BA,AavCA,AWjCA,ArB+DA,AIZA,AU9BA;AIXA,ACHA,AJYA,AHSA,ALeA,ACHA,AYpCA,AJYA,AjBmDA,AOrBA,AT2BA,AavCA,AWjCA,ArB+DA,AIZA,AU9BA;AIXA,ACHA,AJYA,AHSA,ALeA,ACHA,AYpCA,AJYA,AjBmDA,AOrBA,AT2BA,AavCA,AWjCA,ArB+DA,AIZA,AU9BA;AIXA,ACHA,AJYA,AHSA,ALeA,ACHA,AQxBA,AjBmDA,AOrBA,AT2BA,AavCA,AWjCA,ArB+DA,AIZA,AU9BA;AIXA,ACHA,APqBA,ALeA,ACHA,AQxBA,AjBmDA,AOrBA,AT2BA,AavCA,AWjCA,ArB+DA,AIZA,AU9BA;AIXA,ACHA,APqBA,ALeA,ACHA,AQxBA,AjBmDA,AOrBA,AT2BA,AavCA,AWjCA,ArB+DA,AIZA,AU9BA;AIXA,ACHA,APqBA,ALeA,ACHA,AQxBA,AjBmDA,AOrBA,AT2BA,AavCA,AWjCA,ArB+DA,AIZA,AU9BA;AIXA,ACHA,APqBA,ALeA,ACHA,AQxBA,AjBmDA,AOrBA,AT2BA,AavCA,AWjCA,ArB+DA,AIZA,AU9BA;AIXA,ACHA,APqBA,ALeA,ACHA,AQxBA,AjBmDA,AOrBA,AT2BA,AavCA,AWjCA,ArB+DA,AIZA,AU9BA;AIXA,ACHA,APqBA,ALeA,ACHA,AQxBA,AjBmDA,AOrBA,AT2BA,AavCA,AWjCA,ArB+DA,AIZA,AU9BA;AIXA,ACHA,APqBA,ALeA,ACHA,AQxBA,AjBmDA,AOrBA,AT2BA,AavCA,AWjCA,ArB+DA,Ac1CA;AIXA,ACHA,APqBA,ALeA,ACHA,AQxBA,AjBmDA,AOrBA,AT2BA,AavCA,AWjCA,ArB+DA,Ac1CA;AIXA,ACHA,APqBA,ALeA,ACHA,AQxBA,AjBmDA,AOrBA,AT2BA,AavCA,AWjCA,ArB+DA,Ac1CA;AIXA,ACHA,APqBA,ALeA,ACHA,AQxBA,AjBmDA,AOrBA,AT2BA,AavCA,AWjCA,ArB+DA,Ac1CA;AIXA,ACHA,APqBA,ALeA,ACHA,AQxBA,AjBmDA,AOrBA,AT2BA,AavCA,AWjCA,ArB+DA,Ac1CA;AIXA,ACHA,APqBA,ALeA,ACHA,AQxBA,AjBmDA,AOrBA,AT2BA,AavCA,AWjCA,ArB+DA,Ac1CA;AIXA,ACHA,APqBA,ALeA,ACHA,AQxBA,AjBmDA,AOrBA,AT2BA,AavCA,AWjCA,ArB+DA,Ac1CA;AIXA,ACHA,APqBA,ALeA,ACHA,AQxBA,AjBmDA,AOrBA,AT2BA,AavCA,AWjCA,ArB+DA,Ac1CA;AKdA,APqBA,ALeA,ACHA,AQxBA,AjBmDA,AOrBA,AT2BA,AavCA,AWjCA,APqBA;AKdA,APqBA,ALeA,ACHA,AQxBA,AjBmDA,AOrBA,AT2BA,AavCA,AWjCA,APqBA;AKdA,APqBA,ALeA,ACHA,AQxBA,AjBmDA,AOrBA,AT2BA,AavCA,AWjCA,APqBA;AKdA,APqBA,ALeA,ACHA,AQxBA,AjBmDA,AOrBA,AT2BA,AavCA,AWjCA,APqBA;AKdA,APqBA,ALeA,ACHA,AQxBA,AjBmDA,AOrBA,AT2BA,AavCA,AWjCA,APqBA;AKdA,APqBA,ALeA,ACHA,AQxBA,AjBmDA,AOrBA,AT2BA,AavCA,AWjCA,APqBA;AKdA,APqBA,ALeA,ACHA,AQxBA,AjBmDA,AOrBA,AT2BA,AavCA,AWjCA,APqBA;AKdA,APqBA,ALeA,ACHA,AQxBA,AjBmDA,AOrBA,AT2BA,AavCA,AWjCA,APqBA;AKdA,APqBA,ALeA,ACHA,AQxBA,AjBmDA,AOrBA,AT2BA,AavCA,AWjCA,APqBA;AKdA,APqBA,ALeA,ACHA,AQxBA,AjBmDA,AOrBA,AT2BA,AavCA,AWjCA,APqBA;AKdA,APqBA,ALeA,ACHA,AQxBA,AjBmDA,AOrBA,AT2BA,AavCA,AWjCA,APqBA;AKdA,APqBA,ALeA,ACHA,AQxBA,AjBmDA,AOrBA,AT2BA,AavCA,AWjCA,APqBA;AKdA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA,AavCA,AWjCA,APqBA;AKdA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA,AavCA,AWjCA,APqBA;AKdA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA,AavCA,AWjCA,APqBA;AKdA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA,AavCA,AWjCA,APqBA;AKdA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA,AavCA,AIZA;AKdA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA,AiBnDA;AKdA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA,AiBnDA;AKdA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA,AiBnDA;AKdA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA,AiBnDA;AKdA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA,AiBnDA;AKdA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA,AiBnDA;AKdA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA,AiBnDA;AKdA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA,AiBnDA;AKdA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA,AiBnDA;AKdA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA,AiBnDA;AKdA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA,AiBnDA;AKdA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA,AiBnDA;AKdA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA,AiBnDA;AKdA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA,AiBnDA;AKdA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA,AiBnDA;AKdA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA,AiBnDA;AKdA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA,AiBnDA;AKdA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA,AiBnDA;AKdA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA,AiBnDA;AKdA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA,AiBnDA;AKdA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA,AiBnDA;AKdA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA,AiBnDA;AKdA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA,AiBnDA;AKdA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AOrBA,AT2BA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AFMA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AFMA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AFMA;AsBjEA,APqBA,AJYA,AQxBA,AjBmDA,AFMA;AsBjEA,AXiCA,AQxBA,AjBmDA,AFMA;AsBjEA,AXiCA,AQxBA,AjBmDA,AFMA;AsBjEA,AXiCA,AQxBA,AjBmDA,AFMA;AsBjEA,AXiCA,AQxBA,AjBmDA,AFMA;AsBjEA,AXiCA,AQxBA,AjBmDA,AFMA;AsBjEA,AXiCA,AQxBA,AjBmDA,AFMA;AsBjEA,AXiCA,AQxBA,AjBmDA,AFMA;AsBjEA,AXiCA,AQxBA,AjBmDA,AFMA;AsBjEA,AXiCA,AQxBA,AjBmDA,AFMA;AsBjEA,AXiCA,AQxBA,AjBmDA,AFMA;AsBjEA,AXiCA,AQxBA,AjBmDA,AFMA;AsBjEA,AXiCA,AQxBA,AjBmDA,AFMA;AsBjEA,AXiCA,AQxBA,AjBmDA,AFMA;AsBjEA,AXiCA,AQxBA,AjBmDA,AFMA;AsBjEA,AXiCA,AQxBA,AjBmDA,AFMA;AsBjEA,AXiCA,AQxBA,AjBmDA,AFMA;AsBjEA,AXiCA,AQxBA,AjBmDA,AFMA;AsBjEA,AHSA,AjBmDA,AFMA;AsBjEA,AHSA,AjBmDA,AFMA;AsBjEA,AHSA,AjBmDA,AFMA;AsBjEA,AHSA,AjBmDA,AFMA;AsBjEA,AHSA,AjBmDA,AFMA;AsBjEA,AHSA,AjBmDA,AFMA;AsBjEA,AHSA,AjBmDA,AFMA;AsBjEA,AHSA,AjBmDA,AFMA;AsBjEA,AHSA,AjBmDA,AFMA;AmBxDA,AjBmDA,AFMA;AmBxDA,AjBmDA,AFMA;AmBxDA,AjBmDA,AFMA;AmBxDA,AjBmDA,AFMA;AmBxDA,AjBmDA,AFMA;AmBxDA,AjBmDA,AFMA;AmBxDA,AjBmDA,AFMA;AmBxDA,AjBmDA,AFMA;AmBxDA,AjBmDA,AFMA;AmBxDA,AjBmDA,AFMA;AmBxDA,AjBmDA,AFMA;AmBxDA,AjBmDA,AFMA;AmBxDA,AjBmDA,AFMA;AmBxDA,AjBmDA;AiBlDA,AjBmDA;AiBlDA,AjBmDA;AiBlDA,AjBmDA;AiBlDA,AjBmDA;AiBlDA,AjBmDA;AiBlDA,AjBmDA;AiBlDA,AjBmDA;AiBlDA,AjBmDA;AiBlDA,AjBmDA;AiBlDA,AjBmDA;AiBlDA,AjBmDA;AiBlDA,AjBmDA;AiBlDA,AjBmDA;AiBlDA,AjBmDA;AiBlDA,AjBmDA;AiBlDA,AjBmDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["var debug = require('debug')('nodemon');\nvar path = require('path');\nvar monitor = require('./monitor');\nvar cli = require('./cli');\nvar version = require('./version');\nvar util = require('util');\nvar utils = require('./utils');\nvar bus = utils.bus;\nvar help = require('./help');\nvar config = require('./config');\nvar spawn = require('./spawn');\nconst defaults = require('./config/defaults')\nvar eventHandlers = {};\n\n// this is fairly dirty, but theoretically sound since it's part of the\n// stable module API\nconfig.required = utils.isRequired;\n\nfunction nodemon(settings) {\n  bus.emit('boot');\n  nodemon.reset();\n\n  // allow the cli string as the argument to nodemon, and allow for\n  // `node nodemon -V app.js` or just `-V app.js`\n  if (typeof settings === 'string') {\n    settings = settings.trim();\n    if (settings.indexOf('node') !== 0) {\n      if (settings.indexOf('nodemon') !== 0) {\n        settings = 'nodemon ' + settings;\n      }\n      settings = 'node ' + settings;\n    }\n    settings = cli.parse(settings);\n  }\n\n  // set the debug flag as early as possible to get all the detailed logging\n  if (settings.verbose) {\n    utils.debug = true;\n  }\n\n  if (settings.help) {\n    process.stdout._handle.setBlocking(true); // nodejs/node#6456\n    console.log(help(settings.help));\n    if (!config.required) {\n      process.exit(0);\n    }\n  }\n\n  if (settings.version) {\n    version().then(function (v) {\n      console.log(v);\n      if (!config.required) {\n        process.exit(0);\n      }\n    });\n    return;\n  }\n\n  // nodemon tools like grunt-nodemon. This affects where\n  // the script is being run from, and will affect where\n  // nodemon looks for the nodemon.json files\n  if (settings.cwd) {\n    // this is protection to make sure we haven't dont the chdir already...\n    // say like in cli/parse.js (which is where we do this once already!)\n    if (process.cwd() !== path.resolve(config.system.cwd, settings.cwd)) {\n      process.chdir(settings.cwd);\n    }\n  }\n\n  const cwd = process.cwd();\n\n  config.load(settings, function (config) {\n    if (!config.options.dump && !config.options.execOptions.script &&\n      config.options.execOptions.exec === 'node') {\n      if (!config.required) {\n        console.log(help('usage'));\n        process.exit();\n      }\n      return;\n    }\n\n    // before we print anything, update the colour setting on logging\n    utils.colours = config.options.colours;\n\n    // always echo out the current version\n    utils.log.info(version.pinned);\n\n    const cwd = process.cwd();\n\n    if (config.options.cwd) {\n      utils.log.detail('process root: ' + cwd);\n    }\n\n    config.loaded.map(file => file.replace(cwd, '.')).forEach(file => {\n      utils.log.detail('reading config ' + file);\n    });\n\n    if (config.options.stdin && config.options.restartable) {\n      // allow nodemon to restart when the use types 'rs\\n'\n      process.stdin.resume();\n      process.stdin.setEncoding('utf8');\n      process.stdin.on('data', data => {\n        const str = data.toString().trim().toLowerCase();\n\n        // if the keys entered match the restartable value, then restart!\n        if (str === config.options.restartable) {\n          bus.emit('restart');\n        } else if (data.charCodeAt(0) === 12) { // ctrl+l\n          console.clear();\n        }\n      });\n    } else if (config.options.stdin) {\n      // so let's make sure we don't eat the key presses\n      // but also, since we're wrapping, watch out for\n      // special keys, like ctrl+c x 2 or '.exit' or ctrl+d or ctrl+l\n      var ctrlC = false;\n      var buffer = '';\n\n      process.stdin.on('data', function (data) {\n        data = data.toString();\n        buffer += data;\n        const chr = data.charCodeAt(0);\n\n        // if restartable, echo back\n        if (chr === 3) {\n          if (ctrlC) {\n            process.exit(0);\n          }\n\n          ctrlC = true;\n          return;\n        } else if (buffer === '.exit' || chr === 4) { // ctrl+d\n          process.exit();\n        } else if (chr === 13 || chr === 10) { // enter / carriage return\n          buffer = '';\n        } else if (chr === 12) { // ctrl+l\n          console.clear();\n          buffer = '';\n        }\n        ctrlC = false;\n      });\n      if (process.stdin.setRawMode) {\n        process.stdin.setRawMode(true);\n      }\n    }\n\n    if (config.options.restartable) {\n      utils.log.info('to restart at any time, enter `' +\n        config.options.restartable + '`');\n    }\n\n    if (!config.required) {\n      const restartSignal = config.options.signal === 'SIGUSR2' ? 'SIGHUP' : 'SIGUSR2';\n      process.on(restartSignal, nodemon.restart);\n      utils.bus.on('error', () => {\n        utils.log.fail((new Error().stack));\n      });\n      utils.log.detail((config.options.restartable ? 'or ' : '') + 'send ' +\n        restartSignal + ' to ' + process.pid + ' to restart');\n    }\n\n    const ignoring = config.options.monitor.map(function (rule) {\n      if (rule.slice(0, 1) !== '!') {\n        return false;\n      }\n\n      rule = rule.slice(1);\n\n      // don't notify of default ignores\n      if (defaults.ignoreRoot.indexOf(rule) !== -1) {\n        return false;\n        return rule.slice(3).slice(0, -3);\n      }\n\n      if (rule.startsWith(cwd)) {\n        return rule.replace(cwd, '.');\n      }\n\n      return rule;\n    }).filter(Boolean).join(' ');\n    if (ignoring) utils.log.detail('ignoring: ' + ignoring);\n\n    utils.log.info('watching dir(s): ' + config.options.monitor.map(function (rule) {\n      if (rule.slice(0, 1) !== '!') {\n        try {\n          rule = path.relative(process.cwd(), rule);\n        } catch (e) {}\n\n        return rule;\n      }\n\n      return false;\n    }).filter(Boolean).join(' '));\n\n    utils.log.info('watching extensions: ' + (config.options.execOptions.ext || '(all)'));\n\n    if (config.options.dump) {\n      utils.log._log('log', '--------------');\n      utils.log._log('log', 'node: ' + process.version);\n      utils.log._log('log', 'nodemon: ' + version.pinned);\n      utils.log._log('log', 'command: ' + process.argv.join(' '));\n      utils.log._log('log', 'cwd: ' + cwd);\n      utils.log._log('log', ['OS:', process.platform, process.arch].join(' '));\n      utils.log._log('log', '--------------');\n      utils.log._log('log', util.inspect(config, { depth: null }));\n      utils.log._log('log', '--------------');\n      if (!config.required) {\n        process.exit();\n      }\n\n      return;\n    }\n\n    config.run = true;\n\n    if (config.options.stdout === false) {\n      nodemon.on('start', function () {\n        nodemon.stdout = bus.stdout;\n        nodemon.stderr = bus.stderr;\n\n        bus.emit('readable');\n      });\n    }\n\n    if (config.options.events && Object.keys(config.options.events).length) {\n      Object.keys(config.options.events).forEach(function (key) {\n        utils.log.detail('bind ' + key + ' -> `' +\n          config.options.events[key] + '`');\n        nodemon.on(key, function () {\n          if (config.options && config.options.events) {\n            spawn(config.options.events[key], config,\n              [].slice.apply(arguments));\n          }\n        });\n      });\n    }\n\n    monitor.run(config.options);\n\n  });\n\n  return nodemon;\n}\n\nnodemon.restart = function () {\n  utils.log.status('restarting child process');\n  bus.emit('restart');\n  return nodemon;\n};\n\nnodemon.addListener = nodemon.on = function (event, handler) {\n  if (!eventHandlers[event]) { eventHandlers[event] = []; }\n  eventHandlers[event].push(handler);\n  bus.on(event, handler);\n  return nodemon;\n};\n\nnodemon.once = function (event, handler) {\n  if (!eventHandlers[event]) { eventHandlers[event] = []; }\n  eventHandlers[event].push(handler);\n  bus.once(event, function () {\n    debug('bus.once(%s)', event);\n    eventHandlers[event].splice(eventHandlers[event].indexOf(handler), 1);\n    handler.apply(this, arguments);\n  });\n  return nodemon;\n};\n\nnodemon.emit = function () {\n  bus.emit.apply(bus, [].slice.call(arguments));\n  return nodemon;\n};\n\nnodemon.removeAllListeners = function (event) {\n  // unbind only the `nodemon.on` event handlers\n  Object.keys(eventHandlers).filter(function (e) {\n    return event ? e === event : true;\n  }).forEach(function (event) {\n    eventHandlers[event].forEach(function (handler) {\n      bus.removeListener(event, handler);\n      eventHandlers[event].splice(eventHandlers[event].indexOf(handler), 1);\n    });\n  });\n\n  return nodemon;\n};\n\nnodemon.reset = function (done) {\n  bus.emit('reset', done);\n};\n\nbus.on('reset', function (done) {\n  debug('reset');\n  nodemon.removeAllListeners();\n  monitor.run.kill(true, function () {\n    utils.reset();\n    config.reset();\n    config.run = false;\n    if (done) {\n      done();\n    }\n  });\n});\n\n// expose the full config\nnodemon.config = config;\n\nmodule.exports = nodemon;\n\n","module.exports = {\n  run: require('./run'),\n  watch: require('./watch').watch,\n};\n","var debug = require('debug')('nodemon');\nconst statSync = require('fs').statSync;\nvar utils = require('../utils');\nvar bus = utils.bus;\nvar childProcess = require('child_process');\nvar spawn = childProcess.spawn;\nvar exec = childProcess.exec;\nvar fork = childProcess.fork;\nvar watch = require('./watch').watch;\nvar config = require('../config');\nvar child = null; // the actual child process we spawn\nvar killedAfterChange = false;\nvar noop = function () { };\nvar restart = null;\nvar psTree = require('pstree.remy');\nvar path = require('path');\nvar signals = require('./signals');\n\nfunction run(options) {\n  var cmd = config.command.raw;\n\n  var runCmd = !options.runOnChangeOnly || config.lastStarted !== 0;\n  if (runCmd) {\n    utils.log.status('starting `' + config.command.string + '`');\n  }\n\n  /*jshint validthis:true*/\n  restart = run.bind(this, options);\n  run.restart = restart;\n\n  config.lastStarted = Date.now();\n\n  var stdio = ['pipe', 'pipe', 'pipe'];\n\n  if (config.options.stdout) {\n    stdio = ['pipe', process.stdout, process.stderr];\n  }\n\n  if (config.options.stdin === false) {\n    stdio = [process.stdin, process.stdout, process.stderr];\n  }\n\n  var sh = 'sh';\n  var shFlag = '-c';\n\n  const binPath = process.cwd() + '/node_modules/.bin';\n\n  const spawnOptions = {\n    env: Object.assign({}, process.env, options.execOptions.env, {\n      PATH: binPath + ':' + process.env.PATH,\n    }),\n    stdio: stdio,\n  }\n\n  var executable = cmd.executable;\n\n  if (utils.isWindows) {\n    // if the exec includes a forward slash, reverse it for windows compat\n    // but *only* apply to the first command, and none of the arguments.\n    // ref #1251 and #1236\n    if (executable.indexOf('/') !== -1) {\n      executable = executable.split(' ').map((e, i) => {\n        if (i === 0) {\n          return path.normalize(e);\n        }\n        return e;\n      }).join(' ');\n    }\n    // taken from npm's cli: https://git.io/vNFD4\n    sh = process.env.comspec || 'cmd';\n    shFlag = '/d /s /c';\n    spawnOptions.windowsVerbatimArguments = true;\n  }\n\n  var args = runCmd ? utils.stringify(executable, cmd.args) : ':';\n  var spawnArgs = [sh, [shFlag, args], spawnOptions];\n\n  const firstArg = cmd.args[0] || '';\n\n  var inBinPath = false;\n  try {\n    inBinPath = statSync(`${binPath}/${executable}`).isFile();\n  } catch (e) {}\n\n  // hasStdio allows us to correctly handle stdin piping\n  // see: https://git.io/vNtX3\n  const hasStdio = utils.satisfies('>= 6.4.0 || < 5');\n\n  // forking helps with sub-process handling and tends to clean up better\n  // than spawning, but it should only be used under specific conditions\n  const shouldFork =\n    !config.options.spawn &&\n    !inBinPath &&\n    !(firstArg.indexOf('-') === 0) && // don't fork if there's a node exec arg\n    firstArg !== 'inspect' && // don't fork it's `inspect` debugger\n    executable === 'node' && // only fork if node\n    utils.version.major > 4 // only fork if node version > 4\n\n  if (shouldFork) {\n    var forkArgs = cmd.args.slice(1);\n    var env = utils.merge(options.execOptions.env, process.env);\n    stdio.push('ipc');\n    child = fork(options.execOptions.script, forkArgs, {\n      env: env,\n      stdio: stdio,\n      silent: !hasStdio,\n    });\n    utils.log.detail('forking');\n    debug('fork', sh, shFlag, args)\n  } else {\n    utils.log.detail('spawning');\n    child = spawn.apply(null, spawnArgs);\n    debug('spawn', sh, shFlag, args)\n  }\n\n  if (config.required) {\n    var emit = {\n      stdout: function (data) {\n        bus.emit('stdout', data);\n      },\n      stderr: function (data) {\n        bus.emit('stderr', data);\n      },\n    };\n\n    // now work out what to bind to...\n    if (config.options.stdout) {\n      child.on('stdout', emit.stdout).on('stderr', emit.stderr);\n    } else {\n      child.stdout.on('data', emit.stdout);\n      child.stderr.on('data', emit.stderr);\n\n      bus.stdout = child.stdout;\n      bus.stderr = child.stderr;\n    }\n\n    if (shouldFork) {\n      child.on('message', function (message, sendHandle) {\n        bus.emit('message', message, sendHandle);\n      });\n    }\n  }\n\n  bus.emit('start');\n\n  utils.log.detail('child pid: ' + child.pid);\n\n  child.on('error', function (error) {\n    bus.emit('error', error);\n    if (error.code === 'ENOENT') {\n      utils.log.error('unable to run executable: \"' + cmd.executable + '\"');\n      process.exit(1);\n    } else {\n      utils.log.error('failed to start child process: ' + error.code);\n      throw error;\n    }\n  });\n\n  child.on('exit', function (code, signal) {\n    if (child && child.stdin) {\n      process.stdin.unpipe(child.stdin);\n    }\n\n    if (code === 127) {\n      utils.log.error('failed to start process, \"' + cmd.executable +\n        '\" exec not found');\n      bus.emit('error', code);\n      process.exit();\n    }\n\n    // If the command failed with code 2, it may or may not be a syntax error\n    // See: http://git.io/fNOAR\n    // We will only assume a parse error, if the child failed quickly\n    if (code === 2 && Date.now() < config.lastStarted + 500) {\n      utils.log.error('process failed, unhandled exit code (2)');\n      utils.log.error('');\n      utils.log.error('Either the command has a syntax error,');\n      utils.log.error('or it is exiting with reserved code 2.');\n      utils.log.error('');\n      utils.log.error('To keep nodemon running even after a code 2,');\n      utils.log.error('add this to the end of your command: || exit 1');\n      utils.log.error('');\n      utils.log.error('Read more here: https://git.io/fNOAG');\n      utils.log.error('');\n      utils.log.error('nodemon will stop now so that you can fix the command.');\n      utils.log.error('');\n      bus.emit('error', code);\n      process.exit();\n    }\n\n    // In case we killed the app ourselves, set the signal thusly\n    if (killedAfterChange) {\n      killedAfterChange = false;\n      signal = config.signal;\n    }\n    // this is nasty, but it gives it windows support\n    if (utils.isWindows && signal === 'SIGTERM') {\n      signal = config.signal;\n    }\n\n    if (signal === config.signal || code === 0) {\n      // this was a clean exit, so emit exit, rather than crash\n      debug('bus.emit(exit) via ' + config.signal);\n      bus.emit('exit', signal);\n\n      // exit the monitor, but do it gracefully\n      if (signal === config.signal) {\n        return restart();\n      }\n\n      if (code === 0) { // clean exit - wait until file change to restart\n        if (runCmd) {\n          utils.log.status('clean exit - waiting for changes before restart');\n        }\n        child = null;\n      }\n    } else {\n      bus.emit('crash');\n      if (options.exitcrash) {\n        utils.log.fail('app crashed');\n        if (!config.required) {\n          process.exit(1);\n        }\n      } else {\n        utils.log.fail('app crashed - waiting for file changes before' +\n          ' starting...');\n        child = null;\n      }\n    }\n\n    if (config.options.restartable) {\n      // stdin needs to kick in again to be able to listen to the\n      // restart command\n      process.stdin.resume();\n    }\n  });\n\n  run.kill = function (noRestart, callback) {\n    // I hate code like this :(  - Remy (author of said code)\n    if (typeof noRestart === 'function') {\n      callback = noRestart;\n      noRestart = false;\n    }\n\n    if (!callback) {\n      callback = noop;\n    }\n\n    if (child !== null) {\n      // if the stdin piping is on, we need to unpipe, but also close stdin on\n      // the child, otherwise linux can throw EPIPE or ECONNRESET errors.\n      if (options.stdin) {\n        process.stdin.unpipe(child.stdin);\n      }\n\n      // For the on('exit', ...) handler above the following looks like a\n      // crash, so we set the killedAfterChange flag if a restart is planned\n      if (!noRestart) {\n        killedAfterChange = true;\n      }\n\n      /* Now kill the entire subtree of processes belonging to nodemon */\n      var oldPid = child.pid;\n      if (child) {\n        kill(child, config.signal, function () {\n          // this seems to fix the 0.11.x issue with the \"rs\" restart command,\n          // though I'm unsure why. it seems like more data is streamed in to\n          // stdin after we close.\n          if (child && options.stdin && child.stdin && oldPid === child.pid) {\n            child.stdin.end();\n          }\n          callback();\n        });\n      }\n    } else if (!noRestart) {\n      // if there's no child, then we need to manually start the process\n      // this is because as there was no child, the child.on('exit') event\n      // handler doesn't exist which would normally trigger the restart.\n      bus.once('start', callback);\n      restart();\n    } else {\n      callback();\n    }\n  };\n\n  // connect stdin to the child process (options.stdin is on by default)\n  if (options.stdin) {\n    process.stdin.resume();\n    // FIXME decide whether or not we need to decide the encoding\n    // process.stdin.setEncoding('utf8');\n\n    // swallow the stdin error if it happens\n    // ref: https://github.com/remy/nodemon/issues/1195\n    if (hasStdio) {\n      child.stdin.on('error', () => { });\n      process.stdin.pipe(child.stdin);\n    } else {\n      if (child.stdout) {\n        child.stdout.pipe(process.stdout);\n      } else {\n        utils.log.error('running an unsupported version of node ' +\n          process.version);\n        utils.log.error('nodemon may not work as expected - ' +\n          'please consider upgrading to LTS');\n      }\n    }\n\n    bus.once('exit', function () {\n      if (child && process.stdin.unpipe) { // node > 0.8\n        process.stdin.unpipe(child.stdin);\n      }\n    });\n  }\n\n  debug('start watch on: %s', config.options.watch);\n  if (config.options.watch !== false) {\n    watch();\n  }\n}\n\nfunction kill(child, signal, callback) {\n  if (!callback) {\n    callback = function () { };\n  }\n\n  if (utils.isWindows) {\n    // When using CoffeeScript under Windows, child's process is not node.exe\n    // Instead coffee.cmd is launched, which launches cmd.exe, which starts\n    // node.exe as a child process child.kill() would only kill cmd.exe, not\n    // node.exe\n    // Therefore we use the Windows taskkill utility to kill the process and all\n    // its children (/T for tree).\n    // Force kill (/F) the whole child tree (/T) by PID (/PID 123)\n    exec('taskkill /pid ' + child.pid + ' /T /F');\n    callback();\n  } else {\n    // we use psTree to kill the full subtree of nodemon, because when\n    // spawning processes like `coffee` under the `--debug` flag, it'll spawn\n    // it's own child, and that can't be killed by nodemon, so psTree gives us\n    // an array of PIDs that have spawned under nodemon, and we send each the\n    // configured signal (default: SIGUSR2) signal, which fixes #335\n    // note that psTree also works if `ps` is missing by looking in /proc\n    const sig = signal.replace('SIG', '');\n    psTree(child.pid, function (err, kids) {\n      if (psTree.hasPS) {\n        spawn('kill', ['-s', sig, child.pid].concat(kids))\n          .on('close', callback);\n      } else {\n        // make sure we kill from smallest to largest\n        const pids = kids.concat(child.pid).sort();\n        pids.forEach(pid => {\n          exec('kill -' + signals[signal] + ' ' + pid, () => { });\n        });\n        callback();\n      }\n    });\n\n  }\n}\n\n// stubbed out for now, filled in during run\nrun.kill = function (flag, callback) {\n  if (callback) {\n    callback();\n  }\n};\nrun.restart = noop;\n\nbus.on('quit', function onQuit(code) {\n  if (code === undefined) {\n    code = 0;\n  }\n\n  // remove event listener\n  var exitTimer = null;\n  var exit = function () {\n    clearTimeout(exitTimer);\n    exit = noop; // null out in case of race condition\n    child = null;\n    if (!config.required) {\n      // Execute all other quit listeners.\n      bus.listeners('quit').forEach(function (listener) {\n        if (listener !== onQuit) {\n          listener();\n        }\n      });\n      process.exit(code);\n    } else {\n      bus.emit('exit');\n    }\n  };\n\n  // if we're not running already, don't bother with trying to kill\n  if (config.run === false) {\n    return exit();\n  }\n\n  // immediately try to stop any polling\n  config.run = false;\n\n  if (child) {\n    // give up waiting for the kids after 10 seconds\n    exitTimer = setTimeout(exit, 10 * 1000);\n    child.removeAllListeners('exit');\n    child.once('exit', exit);\n\n    kill(child, 'SIGINT');\n  } else {\n    exit();\n  }\n});\n\nbus.on('restart', function () {\n  // run.kill will send a SIGINT to the child process, which will cause it\n  // to terminate, which in turn uses the 'exit' event handler to restart\n  run.kill();\n});\n\n// remove the child file on exit\nprocess.on('exit', function () {\n  utils.log.detail('exiting');\n  if (child) { child.kill(); }\n});\n\n// because windows borks when listening for the SIG* events\nif (!utils.isWindows) {\n  bus.once('boot', () => {\n    // usual suspect: ctrl+c exit\n    process.once('SIGINT', () => bus.emit('quit', 130));\n    process.once('SIGTERM', () => {\n      bus.emit('quit', 143);\n      if (child) { child.kill('SIGTERM'); }\n    });\n  })\n}\n\n\nmodule.exports = run;\n","var noop = function () { };\nvar path = require('path');\nconst semver = require('semver');\nvar version = process.versions.node.split('.') || [null, null, null];\n\nvar utils = (module.exports = {\n  semver: semver,\n  satisfies: test => semver.satisfies(process.versions.node, test),\n  version: {\n    major: parseInt(version[0] || 0, 10),\n    minor: parseInt(version[1] || 0, 10),\n    patch: parseInt(version[2] || 0, 10),\n  },\n  clone: require('./clone'),\n  merge: require('./merge'),\n  bus: require('./bus'),\n  isWindows: process.platform === 'win32',\n  isMac: process.platform === 'darwin',\n  isLinux: process.platform === 'linux',\n  isRequired: (function () {\n    var p = module.parent;\n    while (p) {\n      // in electron.js engine it happens\n      if (!p.filename) {\n        return true;\n      }\n      if (p.filename.indexOf('bin' + path.sep + 'nodemon.js') !== -1) {\n        return false;\n      }\n      p = p.parent;\n    }\n\n    return true;\n  })(),\n  home: process.env.HOME || process.env.HOMEPATH,\n  quiet: function () {\n    // nukes the logging\n    if (!this.debug) {\n      for (var method in utils.log) {\n        if (typeof utils.log[method] === 'function') {\n          utils.log[method] = noop;\n        }\n      }\n    }\n  },\n  reset: function () {\n    if (!this.debug) {\n      for (var method in utils.log) {\n        if (typeof utils.log[method] === 'function') {\n          delete utils.log[method];\n        }\n      }\n    }\n    this.debug = false;\n  },\n  regexpToText: function (t) {\n    return t\n      .replace(/\\.\\*\\\\./g, '*.')\n      .replace(/\\\\{2}/g, '^^')\n      .replace(/\\\\/g, '')\n      .replace(/\\^\\^/g, '\\\\');\n  },\n  stringify: function (exec, args) {\n    // serializes an executable string and array of arguments into a string\n    args = args || [];\n\n    return [exec]\n      .concat(\n      args.map(function (arg) {\n        // if an argument contains a space, we want to show it with quotes\n        // around it to indicate that it is a single argument\n        if (arg.length > 0 && arg.indexOf(' ') === -1) {\n          return arg;\n        }\n        // this should correctly escape nested quotes\n        return JSON.stringify(arg);\n      })\n      )\n      .join(' ')\n      .trim();\n  },\n});\n\nutils.log = require('./log')(utils.isRequired);\n\nObject.defineProperty(utils, 'debug', {\n  set: function (value) {\n    this.log.debug = value;\n  },\n  get: function () {\n    return this.log.debug;\n  },\n});\n\nObject.defineProperty(utils, 'colours', {\n  set: function (value) {\n    this.log.useColours = value;\n  },\n  get: function () {\n    return this.log.useColours;\n  },\n});\n","module.exports = clone;\n\n// via http://stackoverflow.com/a/728694/22617\nfunction clone(obj) {\n  // Handle the 3 simple types, and null or undefined\n  if (null === obj || 'object' !== typeof obj) {\n    return obj;\n  }\n\n  var copy;\n\n  // Handle Date\n  if (obj instanceof Date) {\n    copy = new Date();\n    copy.setTime(obj.getTime());\n    return copy;\n  }\n\n  // Handle Array\n  if (obj instanceof Array) {\n    copy = [];\n    for (var i = 0, len = obj.length; i < len; i++) {\n      copy[i] = clone(obj[i]);\n    }\n    return copy;\n  }\n\n  // Handle Object\n  if (obj instanceof Object) {\n    copy = {};\n    for (var attr in obj) {\n      if (obj.hasOwnProperty && obj.hasOwnProperty(attr)) {\n        copy[attr] = clone(obj[attr]);\n      }\n    }\n    return copy;\n  }\n\n  throw new Error('Unable to copy obj! Its type isn\\'t supported.');\n}","var clone = require('./clone');\n\nmodule.exports = merge;\n\nfunction typesMatch(a, b) {\n  return (typeof a === typeof b) && (Array.isArray(a) === Array.isArray(b));\n}\n\n/**\n * A deep merge of the source based on the target.\n * @param  {Object} source   [description]\n * @param  {Object} target   [description]\n * @return {Object}          [description]\n */\nfunction merge(source, target, result) {\n  if (result === undefined) {\n    result = clone(source);\n  }\n\n  // merge missing values from the target to the source\n  Object.getOwnPropertyNames(target).forEach(function (key) {\n    if (source[key] === undefined) {\n      result[key] = target[key];\n    }\n  });\n\n  Object.getOwnPropertyNames(source).forEach(function (key) {\n    var value = source[key];\n\n    if (target[key] && typesMatch(value, target[key])) {\n      // merge empty values\n      if (value === '') {\n        result[key] = target[key];\n      }\n\n      if (Array.isArray(value)) {\n        if (value.length === 0 && target[key].length) {\n          result[key] = target[key].slice(0);\n        }\n      } else if (typeof value === 'object') {\n        result[key] = merge(value, target[key]);\n      }\n    }\n  });\n\n  return result;\n}","var events = require('events');\nvar debug = require('debug')('nodemon');\nvar util = require('util');\n\nvar Bus = function () {\n  events.EventEmitter.call(this);\n};\n\nutil.inherits(Bus, events.EventEmitter);\n\nvar bus = new Bus();\n\n// /*\nvar collected = {};\nbus.on('newListener', function (event) {\n  debug('bus new listener: %s (%s)', event, bus.listeners(event).length);\n  if (!collected[event]) {\n    collected[event] = true;\n    bus.on(event, function () {\n      debug('bus emit: %s', event);\n    });\n  }\n});\n\n// */\n\n// proxy process messages (if forked) to the bus\nprocess.on('message', function (event) {\n  debug('process.message(%s)', event);\n  bus.emit(event);\n});\n\nvar emit = bus.emit;\n\n// if nodemon was spawned via a fork, allow upstream communication\n// via process.send\nif (process.send) {\n  bus.emit = function (event, data) {\n    process.send({ type: event, data: data });\n    emit.apply(bus, arguments);\n  };\n}\n\nmodule.exports = bus;\n","var colour = require('./colour');\nvar bus = require('./bus');\nvar required = false;\nvar useColours = true;\n\nvar coding = {\n  log: 'black',\n  info: 'yellow',\n  status: 'green',\n  detail: 'yellow',\n  fail: 'red',\n  error: 'red',\n};\n\nfunction log(type, text) {\n  var msg = '[nodemon] ' + (text || '');\n\n  if (useColours) {\n    msg = colour(coding[type], msg);\n  }\n\n  // always push the message through our bus, using nextTick\n  // to help testing and get _out of_ promises.\n  process.nextTick(() => {\n    bus.emit('log', { type: type, message: text, colour: msg });\n  });\n\n  // but if we're running on the command line, also echo out\n  // question: should we actually just consume our own events?\n  if (!required) {\n    if (type === 'error') {\n      console.error(msg);\n    } else {\n      console.log(msg || '');\n    }\n  }\n}\n\nvar Logger = function (r) {\n  if (!(this instanceof Logger)) {\n    return new Logger(r);\n  }\n  this.required(r);\n  return this;\n};\n\nObject.keys(coding).forEach(function (type) {\n  Logger.prototype[type] = log.bind(null, type);\n});\n\n// detail is for messages that are turned on during debug\nLogger.prototype.detail = function (msg) {\n  if (this.debug) {\n    log('detail', msg);\n  }\n};\n\nLogger.prototype.required = function (val) {\n  required = val;\n};\n\nLogger.prototype.debug = false;\nLogger.prototype._log = function (type, msg) {\n  if (required) {\n    bus.emit('log', { type: type, message: msg || '', colour: msg || '' });\n  } else if (type === 'error') {\n    console.error(msg);\n  } else {\n    console.log(msg || '');\n  }\n};\n\nObject.defineProperty(Logger.prototype, 'useColours', {\n  set: function (val) {\n    useColours = val;\n  },\n  get: function () {\n    return useColours;\n  },\n});\n\nmodule.exports = Logger;\n","/**\n * Encodes a string in a colour: red, yellow or green\n * @param  {String} c   colour to highlight in\n * @param  {String} str the string to encode\n * @return {String}     coloured string for terminal printing\n */\nfunction colour(c, str) {\n  return (colour[c] || colour.black) + str + colour.black;\n}\n\nfunction strip(str) {\n  re.lastIndex = 0; // reset position\n  return str.replace(re, '');\n}\n\ncolour.red = '\\x1B[31m';\ncolour.yellow = '\\x1B[33m';\ncolour.green = '\\x1B[32m';\ncolour.black = '\\x1B[39m';\n\nvar reStr = Object.keys(colour).map(key => colour[key]).join('|');\nvar re = new RegExp(('(' + reStr + ')').replace(/\\[/g, '\\\\['), 'g');\n\ncolour.strip = strip;\n\nmodule.exports = colour;\n","module.exports.watch = watch;\nmodule.exports.resetWatchers = resetWatchers;\n\nvar debug = require('debug')('nodemon:watch');\nvar debugRoot = require('debug')('nodemon');\nvar chokidar = require('chokidar');\nvar undefsafe = require('undefsafe');\nvar config = require('../config');\nvar path = require('path');\nvar utils = require('../utils');\nvar bus = utils.bus;\nvar match = require('./match');\nvar watchers = [];\nvar debouncedBus;\n\nbus.on('reset', resetWatchers);\n\nfunction resetWatchers() {\n  debugRoot('resetting watchers');\n  watchers.forEach(function (watcher) {\n    watcher.close();\n  });\n  watchers = [];\n}\n\nfunction watch() {\n  if (watchers.length) {\n    debug('early exit on watch, still watching (%s)', watchers.length);\n    return;\n  }\n\n  var dirs = [].slice.call(config.dirs);\n\n  debugRoot('start watch on: %s', dirs.join(', '));\n  const rootIgnored = config.options.ignore;\n  debugRoot('ignored', rootIgnored);\n\n  var watchedFiles = [];\n\n  const promise = new Promise(function (resolve) {\n    const dotFilePattern = /[/\\\\]\\./;\n    var ignored = match.rulesToMonitor(\n      [], // not needed\n      Array.from(rootIgnored),\n      config\n    ).map(pattern => pattern.slice(1));\n\n    const addDotFile = dirs.filter(dir => dir.match(dotFilePattern));\n\n    // don't ignore dotfiles if explicitly watched.\n    if (addDotFile.length === 0) {\n      ignored.push(dotFilePattern);\n    }\n\n    var watchOptions = {\n      ignorePermissionErrors: true,\n      ignored: ignored,\n      persistent: true,\n      usePolling: config.options.legacyWatch || false,\n      interval: config.options.pollingInterval,\n      // note to future developer: I've gone back and forth on adding `cwd`\n      // to the props and in some cases it fixes bugs but typically it causes\n      // bugs elsewhere (since nodemon is used is so many ways). the final\n      // decision is to *not* use it at all and work around it\n      // cwd: ...\n    };\n\n    if (utils.isWindows) {\n      watchOptions.disableGlobbing = true;\n    }\n\n    if (process.env.TEST) {\n      watchOptions.useFsEvents = false;\n    }\n\n    var watcher = chokidar.watch(\n      dirs,\n      Object.assign({}, watchOptions, config.options.watchOptions || {})\n    );\n\n    watcher.ready = false;\n\n    var total = 0;\n\n    watcher.on('change', filterAndRestart);\n    watcher.on('add', function (file) {\n      if (watcher.ready) {\n        return filterAndRestart(file);\n      }\n\n      watchedFiles.push(file);\n      bus.emit('watching', file);\n      debug('chokidar watching: %s', file);\n    });\n    watcher.on('ready', function () {\n      watchedFiles = Array.from(new Set(watchedFiles)); // ensure no dupes\n      total = watchedFiles.length;\n      watcher.ready = true;\n      resolve(total);\n      debugRoot('watch is complete');\n    });\n\n    watcher.on('error', function (error) {\n      if (error.code === 'EINVAL') {\n        utils.log.error(\n          'Internal watch failed. Likely cause: too many ' +\n          'files being watched (perhaps from the root of a drive?\\n' +\n          'See https://github.com/paulmillr/chokidar/issues/229 for details'\n        );\n      } else {\n        utils.log.error('Internal watch failed: ' + error.message);\n        process.exit(1);\n      }\n    });\n\n    watchers.push(watcher);\n  });\n\n  return promise.catch(e => {\n    // this is a core error and it should break nodemon - so I have to break\n    // out of a promise using the setTimeout\n    setTimeout(() => {\n      throw e;\n    });\n  }).then(function () {\n    utils.log.detail(`watching ${watchedFiles.length} file${\n      watchedFiles.length === 1 ? '' : 's'}`);\n    return watchedFiles;\n  });\n}\n\nfunction filterAndRestart(files) {\n  if (!Array.isArray(files)) {\n    files = [files];\n  }\n\n  if (files.length) {\n    var cwd = process.cwd();\n    if (this.options && this.options.cwd) {\n      cwd = this.options.cwd;\n    }\n\n    utils.log.detail(\n      'files triggering change check: ' +\n      files\n        .map(file => {\n          const res = path.relative(cwd, file);\n          return res;\n        })\n        .join(', ')\n    );\n\n    // make sure the path is right and drop an empty\n    // filenames (sometimes on windows)\n    files = files.filter(Boolean).map(file => {\n      return path.relative(process.cwd(), path.relative(cwd, file));\n    });\n\n    if (utils.isWindows) {\n      // ensure the drive letter is in uppercase (c:\\foo -> C:\\foo)\n      files = files.map(f => {\n        if (f.indexOf(':') === -1) { return f; }\n        return f[0].toUpperCase() + f.slice(1);\n      });\n    }\n\n\n    debug('filterAndRestart on', files);\n\n    var matched = match(\n      files,\n      config.options.monitor,\n      undefsafe(config, 'options.execOptions.ext')\n    );\n\n    debug('matched?', JSON.stringify(matched));\n\n    // if there's no matches, then test to see if the changed file is the\n    // running script, if so, let's allow a restart\n    if (config.options.execOptions.script) {\n      const script = path.resolve(config.options.execOptions.script);\n      if (matched.result.length === 0 && script) {\n        const length = script.length;\n        files.find(file => {\n          if (file.substr(-length, length) === script) {\n            matched = {\n              result: [file],\n              total: 1,\n            };\n            return true;\n          }\n        });\n      }\n    }\n\n    utils.log.detail(\n      'changes after filters (before/after): ' +\n      [files.length, matched.result.length].join('/')\n    );\n\n    // reset the last check so we're only looking at recently modified files\n    config.lastStarted = Date.now();\n\n    if (matched.result.length) {\n      if (config.options.delay > 0) {\n        utils.log.detail('delaying restart for ' + config.options.delay + 'ms');\n        if (debouncedBus === undefined) {\n          debouncedBus = debounce(restartBus, config.options.delay);\n        }\n        debouncedBus(matched);\n      } else {\n        return restartBus(matched);\n      }\n    }\n  }\n}\n\nfunction restartBus(matched) {\n  utils.log.status('restarting due to changes...');\n  matched.result.map(file => {\n    utils.log.detail(path.relative(process.cwd(), file));\n  });\n\n  if (config.options.verbose) {\n    utils.log._log('');\n  }\n\n  bus.emit('restart', matched.result);\n}\n\nfunction debounce(fn, delay) {\n  var timer = null;\n  return function () {\n    const context = this;\n    const args = arguments;\n    clearTimeout(timer);\n    timer = setTimeout(() =>fn.apply(context, args), delay);\n  };\n}\n","/**\n * Manages the internal config of nodemon, checking for the state of support\n * with fs.watch, how nodemon can watch files (using find or fs methods).\n *\n * This is *not* the user's config.\n */\nvar debug = require('debug')('nodemon');\nvar load = require('./load');\nvar rules = require('../rules');\nvar utils = require('../utils');\nvar pinVersion = require('../version').pin;\nvar command = require('./command');\nvar rulesToMonitor = require('../monitor/match').rulesToMonitor;\nvar bus = utils.bus;\n\nfunction reset() {\n  rules.reset();\n\n  config.dirs = [];\n  config.options = { ignore: [], watch: [] };\n  config.lastStarted = 0;\n  config.loaded = [];\n}\n\nvar config = {\n  run: false,\n  system: {\n    cwd: process.cwd(),\n  },\n  required: false,\n  dirs: [],\n  timeout: 1000,\n  options: {},\n};\n\n/**\n * Take user defined settings, then detect the local machine capability, then\n * look for local and global nodemon.json files and merge together the final\n * settings with the config for nodemon.\n *\n * @param  {Object} settings user defined settings for nodemon (typically on\n *  the cli)\n * @param  {Function} ready callback fired once the config is loaded\n */\nconfig.load = function (settings, ready) {\n  reset();\n  var config = this;\n  load(settings, config.options, config, function (options) {\n    config.options = options;\n\n    if (options.watch.length === 0) {\n      // this is to catch when the watch is left blank\n      options.watch.push('*.*');\n    }\n\n    if (options['watch_interval']) { // jshint ignore:line\n      options.watchInterval = options['watch_interval']; // jshint ignore:line\n    }\n\n    config.watchInterval = options.watchInterval || null;\n    if (options.signal) {\n      config.signal = options.signal;\n    }\n\n    var cmd = command(config.options);\n    config.command = {\n      raw: cmd,\n      string: utils.stringify(cmd.executable, cmd.args),\n    };\n\n    // now run automatic checks on system adding to the config object\n    options.monitor = rulesToMonitor(options.watch, options.ignore, config);\n\n    var cwd = process.cwd();\n    debug('config: dirs', config.dirs);\n    if (config.dirs.length === 0) {\n      config.dirs.unshift(cwd);\n    }\n\n    bus.emit('config:update', config);\n    pinVersion().then(function () {\n      ready(config);\n    }).catch(e => {\n      // this doesn't help testing, but does give exposure on syntax errors\n      console.error(e.stack);\n      setTimeout(() => { throw e; }, 0);\n    });\n  });\n};\n\nconfig.reset = reset;\n\nmodule.exports = config;\n","var debug = require('debug')('nodemon');\nvar fs = require('fs');\nvar path = require('path');\nvar exists = fs.exists || path.exists;\nvar utils = require('../utils');\nvar rules = require('../rules');\nvar parse = require('../rules/parse');\nvar exec = require('./exec');\nvar defaults = require('./defaults');\n\nmodule.exports = load;\nmodule.exports.mutateExecOptions = mutateExecOptions;\n\nvar existsSync = fs.existsSync || path.existsSync;\n\nfunction findAppScript() {\n  // nodemon has been run alone, so try to read the package file\n  // or try to read the index.js file\n  if (existsSync('./index.js')) {\n    return 'index.js';\n  }\n}\n\n/**\n * Load the nodemon config, first reading the global root/nodemon.json, then\n * the local nodemon.json to the exec and then overwriting using any user\n * specified settings (i.e. from the cli)\n *\n * @param  {Object} settings user defined settings\n * @param  {Function} ready    callback that receives complete config\n */\nfunction load(settings, options, config, callback) {\n  config.loaded = [];\n  // first load the root nodemon.json\n  loadFile(options, config, utils.home, function (options) {\n    // then load the user's local configuration file\n    if (settings.configFile) {\n      options.configFile = path.resolve(settings.configFile);\n    }\n    loadFile(options, config, process.cwd(), function (options) {\n      // Then merge over with the user settings (parsed from the cli).\n      // Note that merge protects and favours existing values over new values,\n      // and thus command line arguments get priority\n      options = utils.merge(settings, options);\n\n      // legacy support\n      if (!Array.isArray(options.ignore)) {\n        options.ignore = [options.ignore];\n      }\n\n      if (!options.ignoreRoot) {\n        options.ignoreRoot = defaults.ignoreRoot;\n      }\n\n      // blend the user ignore and the default ignore together\n      if (options.ignoreRoot && options.ignore) {\n        if (!Array.isArray(options.ignoreRoot)) {\n          options.ignoreRoot = [options.ignoreRoot];\n        }\n        options.ignore = options.ignoreRoot.concat(options.ignore);\n      } else {\n        options.ignore = defaults.ignore.concat(options.ignore);\n      }\n\n\n      // add in any missing defaults\n      options = utils.merge(options, defaults);\n\n      if (!options.script && !options.exec) {\n        var found = findAppScript();\n        if (found) {\n          if (!options.args) {\n            options.args = [];\n          }\n          // if the script is found as a result of not being on the command\n          // line, then we move any of the pre double-dash args in execArgs\n          const n = options.scriptPosition || options.args.length;\n          options.execArgs = (options.execArgs || [])\n            .concat(options.args.splice(0, n));\n          options.scriptPosition = null;\n\n          options.script = found;\n        }\n      }\n\n      mutateExecOptions(options);\n\n      if (options.quiet) {\n        utils.quiet();\n      }\n\n      if (options.verbose) {\n        utils.debug = true;\n      }\n\n      // simplify the ready callback to be called after the rules are normalised\n      // from strings to regexp through the rules lib. Note that this gets\n      // created *after* options is overwritten twice in the lines above.\n      var ready = function (options) {\n        normaliseRules(options, callback);\n      };\n\n      // if we didn't pick up a nodemon.json file & there's no cli ignores\n      // then try loading an old style .nodemonignore file\n      if (config.loaded.length === 0) {\n        var legacy = loadLegacyIgnore.bind(null, options, config, ready);\n\n        // first try .nodemonignore, if that doesn't exist, try nodemon-ignore\n        return legacy('.nodemonignore', function () {\n          legacy('nodemon-ignore', function (options) {\n            ready(options);\n          });\n        });\n      }\n\n      ready(options);\n    });\n  });\n}\n\n/**\n * Loads the old style nodemonignore files which is a list of patterns\n * in a file to ignore\n *\n * @param  {Object} options    nodemon user options\n * @param  {Function} success\n * @param  {String} filename   ignore file (.nodemonignore or nodemon-ignore)\n * @param  {Function} fail     (optional) failure callback\n */\nfunction loadLegacyIgnore(options, config, success, filename, fail) {\n  var ignoreFile = path.join(process.cwd(), filename);\n\n  exists(ignoreFile, function (exists) {\n    if (exists) {\n      config.loaded.push(ignoreFile);\n      return parse(ignoreFile, function (error, rules) {\n        options.ignore = rules.raw;\n        success(options);\n      });\n    }\n\n    if (fail) {\n      fail(options);\n    } else {\n      success(options);\n    }\n  });\n}\n\nfunction normaliseRules(options, ready) {\n  // convert ignore and watch options to rules/regexp\n  rules.watch.add(options.watch);\n  rules.ignore.add(options.ignore);\n\n  // normalise the watch and ignore arrays\n  options.watch = options.watch === false ? false : rules.rules.watch;\n  options.ignore = rules.rules.ignore;\n\n  ready(options);\n}\n\n/**\n * Looks for a config in the current working directory, and a config in the\n * user's home directory, merging the two together, giving priority to local\n * config. This can then be overwritten later by command line arguments\n *\n * @param  {Function} ready callback to pass loaded settings to\n */\nfunction loadFile(options, config, dir, ready) {\n  if (!ready) {\n    ready = function () { };\n  }\n\n  var callback = function (settings) {\n    // prefer the local nodemon.json and fill in missing items using\n    // the global options\n    ready(utils.merge(settings, options));\n  };\n\n  if (!dir) {\n    return callback({});\n  }\n\n  var filename = options.configFile || path.join(dir, 'nodemon.json');\n\n  if (config.loaded.indexOf(filename) !== -1) {\n    // don't bother re-parsing the same config file\n    return callback({});\n  }\n\n  fs.readFile(filename, 'utf8', function (err, data) {\n    if (err) {\n      if (err.code === 'ENOENT') {\n        if (!options.configFile && dir !== utils.home) {\n          // if no specified local config file and local nodemon.json\n          // doesn't exist, try the package.json\n          return loadPackageJSON(config, callback);\n        }\n      }\n      return callback({});\n    }\n\n    var settings = {};\n\n    try {\n      settings = JSON.parse(data.toString('utf8').replace(/^\\uFEFF/, ''));\n      if (!filename.endsWith('package.json') || settings.nodemonConfig) {\n        config.loaded.push(filename);\n      }\n    } catch (e) {\n      utils.log.fail('Failed to parse config ' + filename);\n      console.error(e);\n      process.exit(1);\n    }\n\n    // options values will overwrite settings\n    callback(settings);\n  });\n}\n\nfunction loadPackageJSON(config, ready) {\n  if (!ready) {\n    ready = () => { };\n  }\n\n  const dir = process.cwd();\n  const filename = path.join(dir, 'package.json');\n  const packageLoadOptions = { configFile: filename };\n  return loadFile(packageLoadOptions, config, dir, settings => {\n    ready(settings.nodemonConfig || {});\n  });\n}\n\nfunction mutateExecOptions(options) {\n  // work out the execOptions based on the final config we have\n  options.execOptions = exec({\n    script: options.script,\n    exec: options.exec,\n    args: options.args,\n    scriptPosition: options.scriptPosition,\n    nodeArgs: options.nodeArgs,\n    execArgs: options.execArgs,\n    ext: options.ext,\n    env: options.env,\n  }, options.execMap);\n\n  // clean up values that we don't need at the top level\n  delete options.scriptPosition;\n  delete options.script;\n  delete options.args;\n  delete options.ext;\n\n  return options;\n}\n","\nvar utils = require('../utils');\nvar add = require('./add');\nvar parse = require('./parse');\n\n// exported\nvar rules = { ignore: [], watch: [] };\n\n/**\n * Loads a nodemon config file and populates the ignore\n * and watch rules with it's contents, and calls callback\n * with the new rules\n *\n * @param  {String} filename\n * @param  {Function} callback\n */\nfunction load(filename, callback) {\n  parse(filename, function (err, result) {\n    if (err) {\n      // we should have bombed already, but\n      utils.log.error(err);\n      callback(err);\n    }\n\n    if (result.raw) {\n      result.raw.forEach(add.bind(null, rules, 'ignore'));\n    } else {\n      result.ignore.forEach(add.bind(null, rules, 'ignore'));\n      result.watch.forEach(add.bind(null, rules, 'watch'));\n    }\n\n    callback(null, rules);\n  });\n}\n\nmodule.exports = {\n  reset: function () { // just used for testing\n    rules.ignore.length = rules.watch.length = 0;\n    delete rules.ignore.re;\n    delete rules.watch.re;\n  },\n  load: load,\n  ignore: {\n    test: add.bind(null, rules, 'ignore'),\n    add: add.bind(null, rules, 'ignore'),\n  },\n  watch: {\n    test: add.bind(null, rules, 'watch'),\n    add: add.bind(null, rules, 'watch'),\n  },\n  add: add.bind(null, rules),\n  rules: rules,\n};","\n\nvar utils = require('../utils');\n\n// internal\nvar reEscComments = /\\\\#/g;\n// note that '^^' is used in place of escaped comments\nvar reUnescapeComments = /\\^\\^/g;\nvar reComments = /#.*$/;\nvar reEscapeChars = /[.|\\-[\\]()\\\\]/g;\nvar reAsterisk = /\\*/g;\n\nmodule.exports = add;\n\n/**\n * Converts file patterns or regular expressions to nodemon\n * compatible RegExp matching rules. Note: the `rules` argument\n * object is modified to include the new rule and new RegExp\n *\n * ### Example:\n *\n *     var rules = { watch: [], ignore: [] };\n *     add(rules, 'watch', '*.js');\n *     add(rules, 'ignore', '/public/');\n *     add(rules, 'watch', ':(\\d)*\\.js'); // note: string based regexp\n *     add(rules, 'watch', /\\d*\\.js/);\n *\n * @param {Object} rules containing `watch` and `ignore`. Also updated during\n *                       execution\n * @param {String} which must be either \"watch\" or \"ignore\"\n * @param {String|RegExp} the actual rule.\n */\nfunction add(rules, which, rule) {\n  if (!{ ignore: 1, watch: 1}[which]) {\n    throw new Error('rules/index.js#add requires \"ignore\" or \"watch\" as the ' +\n      'first argument');\n  }\n\n  if (Array.isArray(rule)) {\n    rule.forEach(function (rule) {\n      add(rules, which, rule);\n    });\n    return;\n  }\n\n  // support the rule being a RegExp, but reformat it to\n  // the custom :<regexp> format that we're working with.\n  if (rule instanceof RegExp) {\n    // rule = ':' + rule.toString().replace(/^\\/(.*?)\\/$/g, '$1');\n    utils.log.error('RegExp format no longer supported, but globs are.');\n    return;\n  }\n\n  // remove comments and trim lines\n  // this mess of replace methods is escaping \"\\#\" to allow for emacs temp files\n\n  // first up strip comments and remove blank head or tails\n  rule = (rule || '').replace(reEscComments, '^^')\n             .replace(reComments, '')\n             .replace(reUnescapeComments, '#').trim();\n\n  var regexp = false;\n\n  if (typeof rule === 'string' && rule.substring(0, 1) === ':') {\n    rule = rule.substring(1);\n    utils.log.error('RegExp no longer supported: ' + rule);\n    regexp = true;\n  } else if (rule.length === 0) {\n    // blank line (or it was a comment)\n    return;\n  }\n\n  if (regexp) {\n    // rules[which].push(rule);\n  } else {\n    // rule = rule.replace(reEscapeChars, '\\\\$&')\n    // .replace(reAsterisk, '.*');\n\n    rules[which].push(rule);\n    // compile a regexp of all the rules for this ignore or watch\n    var re = rules[which].map(function (rule) {\n      return rule.replace(reEscapeChars, '\\\\$&')\n                 .replace(reAsterisk, '.*');\n    }).join('|');\n\n    // used for the directory matching\n    rules[which].re = new RegExp(re);\n  }\n}\n","\nvar fs = require('fs');\n\n/**\n * Parse the nodemon config file, supporting both old style\n * plain text config file, and JSON version of the config\n *\n * @param  {String}   filename\n * @param  {Function} callback\n */\nfunction parse(filename, callback) {\n  var rules = {\n    ignore: [],\n    watch: [],\n  };\n\n  fs.readFile(filename, 'utf8', function (err, content) {\n\n    if (err) {\n      return callback(err);\n    }\n\n    var json = null;\n    try {\n      json = JSON.parse(content);\n    } catch (e) {}\n\n    if (json !== null) {\n      rules = {\n        ignore: json.ignore || [],\n        watch: json.watch || [],\n      };\n\n      return callback(null, rules);\n    }\n\n    // otherwise return the raw file\n    return callback(null, { raw: content.split(/\\n/) });\n  });\n}\n\nmodule.exports = parse;\n\n","const path = require('path');\nconst fs = require('fs');\nconst existsSync = fs.existsSync;\nconst utils = require('../utils');\n\nmodule.exports = exec;\nmodule.exports.expandScript = expandScript;\n\n/**\n * Reads the cwd/package.json file and looks to see if it can load a script\n * and possibly an exec first from package.main, then package.start.\n *\n * @return {Object} exec & script if found\n */\nfunction execFromPackage() {\n  // doing a try/catch because we can't use the path.exist callback pattern\n  // or we could, but the code would get messy, so this will do exactly\n  // what we're after - if the file doesn't exist, it'll throw.\n  try {\n    // note: this isn't nodemon's package, it's the user's cwd package\n    var pkg = require(path.join(process.cwd(), 'package.json'));\n    if (pkg.main !== undefined) {\n      // no app found to run - so give them a tip and get the feck out\n      return { exec: null, script: pkg.main };\n    }\n\n    if (pkg.scripts && pkg.scripts.start) {\n      return { exec: pkg.scripts.start };\n    }\n  } catch (e) { }\n\n  return null;\n}\n\nfunction replace(map, str) {\n  var re = new RegExp('{{(' + Object.keys(map).join('|') + ')}}', 'g');\n  return str.replace(re, function (all, m) {\n    return map[m] || all || '';\n  });\n}\n\nfunction expandScript(script, ext) {\n  if (!ext) {\n    ext = '.js';\n  }\n  if (script.indexOf(ext) !== -1) {\n    return script;\n  }\n\n  if (existsSync(path.resolve(script))) {\n    return script;\n  }\n\n  if (existsSync(path.resolve(script + ext))) {\n    return script + ext;\n  }\n\n  return script;\n}\n\n/**\n * Discovers all the options required to run the script\n * and if a custom exec has been passed in, then it will\n * also try to work out what extensions to monitor and\n * whether there's a special way of running that script.\n *\n * @param  {Object} nodemonOptions\n * @param  {Object} execMap\n * @return {Object} new and updated version of nodemonOptions\n */\nfunction exec(nodemonOptions, execMap) {\n  if (!execMap) {\n    execMap = {};\n  }\n\n  var options = utils.clone(nodemonOptions || {});\n  var script;\n\n  // if there's no script passed, try to get it from the first argument\n  if (!options.script && (options.args || []).length) {\n    script = expandScript(options.args[0],\n      options.ext && ('.' + (options.ext || 'js').split(',')[0]));\n\n    // if the script was found, shift it off our args\n    if (script !== options.args[0]) {\n      options.script = script;\n      options.args.shift();\n    }\n  }\n\n  // if there's no exec found yet, then try to read it from the local\n  // package.json this logic used to sit in the cli/parse, but actually the cli\n  // should be parsed first, then the user options (via nodemon.json) then\n  // finally default down to pot shots at the directory via package.json\n  if (!options.exec && !options.script) {\n    var found = execFromPackage();\n    if (found !== null) {\n      if (found.exec) {\n        options.exec = found.exec;\n      }\n      if (!options.script) {\n        options.script = found.script;\n      }\n      if (Array.isArray(options.args) &&\n        options.scriptPosition === null) {\n        options.scriptPosition = options.args.length;\n      }\n    }\n  }\n\n  // var options = utils.clone(nodemonOptions || {});\n  script = path.basename(options.script || '');\n\n  var scriptExt = path.extname(script).slice(1);\n\n  var extension = options.ext;\n  if (extension === undefined) {\n    var isJS = scriptExt === 'js' || scriptExt === 'mjs';\n    extension = (isJS || !scriptExt) ? 'js,mjs' : scriptExt;\n    extension += ',json'; // Always watch JSON files\n  }\n\n  var execDefined = !!options.exec;\n\n  // allows the user to simplify cli usage:\n  // https://github.com/remy/nodemon/issues/195\n  // but always give preference to the user defined argument\n  if (!options.exec && execMap[scriptExt] !== undefined) {\n    options.exec = execMap[scriptExt];\n    execDefined = true;\n  }\n\n  options.execArgs = nodemonOptions.execArgs || [];\n\n  if (Array.isArray(options.exec)) {\n    options.execArgs = options.exec;\n    options.exec = options.execArgs.shift();\n  }\n\n  if (options.exec === undefined) {\n    options.exec = 'node';\n  } else {\n    // allow variable substitution for {{filename}} and {{pwd}}\n    var substitution = replace.bind(null, {\n      filename: options.script,\n      pwd: process.cwd(),\n    });\n\n    var newExec = substitution(options.exec);\n    if (newExec !== options.exec &&\n      options.exec.indexOf('{{filename}}') !== -1) {\n      options.script = null;\n    }\n    options.exec = newExec;\n\n    var newExecArgs = options.execArgs.map(substitution);\n    if (newExecArgs.join('') !== options.execArgs.join('')) {\n      options.execArgs = newExecArgs;\n      delete options.script;\n    }\n  }\n\n\n  if (options.exec === 'node' && options.nodeArgs && options.nodeArgs.length) {\n    options.execArgs = options.execArgs.concat(options.nodeArgs);\n  }\n\n  // note: indexOf('coffee') handles both .coffee and .litcoffee\n  if (!execDefined && options.exec === 'node' &&\n    scriptExt.indexOf('coffee') !== -1) {\n    options.exec = 'coffee';\n\n    // we need to get execArgs set before the script\n    // for example, in `nodemon --debug my-script.coffee --my-flag`, debug is an\n    // execArg, while my-flag is a script arg\n    var leadingArgs = (options.args || []).splice(0, options.scriptPosition);\n    options.execArgs = options.execArgs.concat(leadingArgs);\n    options.scriptPosition = 0;\n\n    if (options.execArgs.length > 0) {\n      // because this is the coffee executable, we need to combine the exec args\n      // into a single argument after the nodejs flag\n      options.execArgs = ['--nodejs', options.execArgs.join(' ')];\n    }\n  }\n\n  if (options.exec === 'coffee') {\n    // don't override user specified extension tracking\n    if (options.ext === undefined) {\n      if (extension) { extension += ','; }\n      extension += 'coffee,litcoffee';\n    }\n\n    // because windows can't find 'coffee', it needs the real file 'coffee.cmd'\n    if (utils.isWindows) {\n      options.exec += '.cmd';\n    }\n  }\n\n  // allow users to make a mistake on the extension to monitor\n  // converts .js, pug => js,pug\n  // BIG NOTE: user can't do this: nodemon -e *.js\n  // because the terminal will automatically expand the glob against\n  // the file system :(\n  extension = (extension.match(/[^,*\\s]+/g) || [])\n    .map(ext => ext.replace(/^\\./, ''))\n    .join(',');\n\n  options.ext = extension;\n\n  if (options.script) {\n    options.script = expandScript(options.script,\n      extension && ('.' + extension.split(',')[0]));\n  }\n\n  options.env = {};\n  // make sure it's an object (and since we don't have )\n  if (({}).toString.apply(nodemonOptions.env) === '[object Object]') {\n    options.env = utils.clone(nodemonOptions.env);\n  } else if (nodemonOptions.env !== undefined) {\n    throw new Error('nodemon env values must be an object: { PORT: 8000 }');\n  }\n\n  return options;\n}\n","var ignoreRoot = require('ignore-by-default').directories();\n\n// default options for config.options\nmodule.exports = {\n  restartable: 'rs',\n  colours: true,\n  execMap: {\n    py: 'python',\n    rb: 'ruby',\n    ts: 'ts-node',\n    // more can be added here such as ls: lsc - but please ensure it's cross\n    // compatible with linux, mac and windows, or make the default.js\n    // dynamically append the `.cmd` for node based utilities\n  },\n  ignoreRoot: ignoreRoot.map(_ => `**/${_}/**`),\n  watch: ['*.*'],\n  stdin: true,\n  runOnChangeOnly: false,\n  verbose: false,\n  signal: 'SIGUSR2',\n  // 'stdout' refers to the default behaviour of a required nodemon's child,\n  // but also includes stderr. If this is false, data is still dispatched via\n  // nodemon.on('stdout/stderr')\n  stdout: true,\n  watchOptions: {\n\n  },\n};\n","module.exports = version;\nmodule.exports.pin = pin;\n\nvar fs = require('fs');\nvar path = require('path');\nvar exec = require('child_process').exec;\nvar root = null;\n\nfunction pin() {\n  return version().then(function (v) {\n    version.pinned = v;\n  });\n}\n\nfunction version(callback) {\n  // first find the package.json as this will be our root\n  var promise = findPackage(path.dirname(module.parent.filename))\n    .then(function (dir) {\n      // now try to load the package\n      var v = require(path.resolve(dir, 'package.json')).version;\n\n      if (v && v !== '0.0.0-development') {\n        return v;\n      }\n\n      root = dir;\n\n      // else we're in development, give the commit out\n      // get the last commit and whether the working dir is dirty\n      var promises = [\n        branch().catch(function () { return 'master'; }),\n        commit().catch(function () { return '<none>'; }),\n        dirty().catch(function () { return 0; }),\n      ];\n\n      // use the cached result as the export\n      return Promise.all(promises).then(function (res) {\n        var branch = res[0];\n        var commit = res[1];\n        var dirtyCount = parseInt(res[2], 10);\n        var curr = branch + ': ' + commit;\n        if (dirtyCount !== 0) {\n          curr += ' (' + dirtyCount + ' dirty files)';\n        }\n\n        return curr;\n      });\n    }).catch(function (error) {\n      console.log(error.stack);\n      throw error;\n    });\n\n  if (callback) {\n    promise.then(function (res) {\n      callback(null, res);\n    }, callback);\n  }\n\n  return promise;\n}\n\nfunction findPackage(dir) {\n  if (dir === '/') {\n    return Promise.reject(new Error('package not found'));\n  }\n  return new Promise(function (resolve) {\n    fs.stat(path.resolve(dir, 'package.json'), function (error, exists) {\n      if (error || !exists) {\n        return resolve(findPackage(path.resolve(dir, '..')));\n      }\n\n      resolve(dir);\n    });\n  });\n}\n\nfunction command(cmd) {\n  return new Promise(function (resolve, reject) {\n    exec(cmd, { cwd: root }, function (err, stdout, stderr) {\n      var error = stderr.trim();\n      if (error) {\n        return reject(new Error(error));\n      }\n      resolve(stdout.split('\\n').join(''));\n    });\n  });\n}\n\nfunction commit() {\n  return command('git rev-parse HEAD');\n}\n\nfunction branch() {\n  return command('git rev-parse --abbrev-ref HEAD');\n}\n\nfunction dirty() {\n  return command('expr $(git status --porcelain 2>/dev/null| ' +\n    'egrep \"^(M| M)\" | wc -l)');\n}\n","module.exports = command;\n\n/**\n * command constructs the executable command to run in a shell including the\n * user script, the command arguments.\n *\n * @param  {Object} settings Object as:\n *                           { execOptions: {\n *                               exec: String,\n *                               [script: String],\n *                               [scriptPosition: Number],\n *                               [execArgs: Array<string>]\n *                             }\n *                           }\n * @return {Object}          an object with the node executable and the\n *                           arguments to the command\n */\nfunction command(settings) {\n  var options = settings.execOptions;\n  var executable = options.exec;\n  var args = [];\n\n  // after \"executable\" go the exec args (like --debug, etc)\n  if (options.execArgs) {\n    [].push.apply(args, options.execArgs);\n  }\n\n  // then goes the user's script arguments\n  if (options.args) {\n    [].push.apply(args, options.args);\n  }\n\n  // after the \"executable\" goes the user's script\n  if (options.script) {\n    args.splice((options.scriptPosition || 0) +\n      options.execArgs.length, 0, options.script);\n  }\n\n  return {\n    executable: executable,\n    args: args,\n  };\n}\n","const minimatch = require('minimatch');\nconst path = require('path');\nconst fs = require('fs');\nconst debug = require('debug')('nodemon:match');\nconst utils = require('../utils');\n\nmodule.exports = match;\nmodule.exports.rulesToMonitor = rulesToMonitor;\n\nfunction rulesToMonitor(watch, ignore, config) {\n  var monitor = [];\n\n  if (!Array.isArray(ignore)) {\n    if (ignore) {\n      ignore = [ignore];\n    } else {\n      ignore = [];\n    }\n  }\n\n  if (!Array.isArray(watch)) {\n    if (watch) {\n      watch = [watch];\n    } else {\n      watch = [];\n    }\n  }\n\n  if (watch && watch.length) {\n    monitor = utils.clone(watch);\n  }\n\n  if (ignore) {\n    [].push.apply(monitor, (ignore || []).map(function (rule) {\n      return '!' + rule;\n    }));\n  }\n\n  var cwd = process.cwd();\n\n  // next check if the monitored paths are actual directories\n  // or just patterns - and expand the rule to include *.*\n  monitor = monitor.map(function (rule) {\n    var not = rule.slice(0, 1) === '!';\n\n    if (not) {\n      rule = rule.slice(1);\n    }\n\n    if (rule === '.' || rule === '.*') {\n      rule = '*.*';\n    }\n\n    var dir = path.resolve(cwd, rule);\n\n    try {\n      var stat = fs.statSync(dir);\n      if (stat.isDirectory()) {\n        rule = dir;\n        if (rule.slice(-1) !== '/') {\n          rule += '/';\n        }\n        rule += '**/*';\n\n        // `!not` ... sorry.\n        if (!not) {\n          config.dirs.push(dir);\n        }\n      } else {\n        // ensures we end up in the check that tries to get a base directory\n        // and then adds it to the watch list\n        throw new Error();\n      }\n    } catch (e) {\n      var base = tryBaseDir(dir);\n      if (!not && base) {\n        if (config.dirs.indexOf(base) === -1) {\n          config.dirs.push(base);\n        }\n      }\n    }\n\n    if (rule.slice(-1) === '/') {\n      // just slap on a * anyway\n      rule += '*';\n    }\n\n    // if the url ends with * but not **/* and not *.*\n    // then convert to **/* - somehow it was missed :-\\\n    if (rule.slice(-4) !== '**/*' &&\n      rule.slice(-1) === '*' &&\n      rule.indexOf('*.') === -1) {\n\n      if (rule.slice(-2) !== '**') {\n        rule += '*/*';\n      }\n    }\n\n\n    return (not ? '!' : '') + rule;\n  });\n\n  return monitor;\n}\n\nfunction tryBaseDir(dir) {\n  var stat;\n  if (/[?*\\{\\[]+/.test(dir)) { // if this is pattern, then try to find the base\n    try {\n      var base = path.dirname(dir.replace(/([?*\\{\\[]+.*$)/, 'foo'));\n      stat = fs.statSync(base);\n      if (stat.isDirectory()) {\n        return base;\n      }\n    } catch (error) {\n      // console.log(error);\n    }\n  } else {\n    try {\n      stat = fs.statSync(dir);\n      // if this path is actually a single file that exists, then just monitor\n      // that, *specifically*.\n      if (stat.isFile() || stat.isDirectory()) {\n        return dir;\n      }\n    } catch (e) { }\n  }\n\n  return false;\n}\n\nfunction match(files, monitor, ext) {\n  // sort the rules by highest specificity (based on number of slashes)\n  // ignore rules (!) get sorted highest as they take precedent\n  const cwd = process.cwd();\n  var rules = monitor.sort(function (a, b) {\n    var r = b.split(path.sep).length - a.split(path.sep).length;\n    var aIsIgnore = a.slice(0, 1) === '!';\n    var bIsIgnore = b.slice(0, 1) === '!';\n\n    if (aIsIgnore || bIsIgnore) {\n      if (aIsIgnore) {\n        return -1;\n      }\n\n      return 1;\n    }\n\n    if (r === 0) {\n      return b.length - a.length;\n    }\n    return r;\n  }).map(function (s) {\n    var prefix = s.slice(0, 1);\n\n    if (prefix === '!') {\n      if (s.indexOf('!' + cwd) === 0) {\n        return s;\n      }\n      return '!**' + (prefix !== path.sep ? path.sep : '') + s.slice(1);\n    }\n\n    // if it starts with a period, then let's get the relative path\n    if (s.indexOf('.') === 0) {\n      return path.resolve(cwd, s);\n    }\n\n    if (s.indexOf(cwd) === 0) {\n      return s;\n    }\n\n    return '**' + (prefix !== path.sep ? path.sep : '') + s;\n  });\n\n  debug('rules', rules);\n\n  var good = [];\n  var whitelist = []; // files that we won't check against the extension\n  var ignored = 0;\n  var watched = 0;\n  var usedRules = [];\n  var minimatchOpts = {\n    dot: true,\n  };\n\n  // enable case-insensitivity on Windows\n  if (utils.isWindows) {\n    minimatchOpts.nocase = true;\n  }\n\n  files.forEach(function (file) {\n    file = path.resolve(cwd, file);\n\n    var matched = false;\n    for (var i = 0; i < rules.length; i++) {\n      if (rules[i].slice(0, 1) === '!') {\n        if (!minimatch(file, rules[i], minimatchOpts)) {\n          ignored++;\n          matched = true;\n          break;\n        }\n      } else {\n        debug('match', file, minimatch(file, rules[i], minimatchOpts));\n        if (minimatch(file, rules[i], minimatchOpts)) {\n          watched++;\n\n          // don't repeat the output if a rule is matched\n          if (usedRules.indexOf(rules[i]) === -1) {\n            usedRules.push(rules[i]);\n            utils.log.detail('matched rule: ' + rules[i]);\n          }\n\n          // if the rule doesn't match the WATCH EVERYTHING\n          // but *does* match a rule that ends with *.*, then\n          // white list it - in that we don't run it through\n          // the extension check too.\n          if (rules[i] !== '**' + path.sep + '*.*' &&\n            rules[i].slice(-3) === '*.*') {\n            whitelist.push(file);\n          } else if (path.basename(file) === path.basename(rules[i])) {\n            // if the file matches the actual rule, then it's put on whitelist\n            whitelist.push(file);\n          } else {\n            good.push(file);\n          }\n          matched = true;\n          break;\n        } else {\n          // utils.log.detail('no match: ' + rules[i], file);\n        }\n      }\n    }\n    if (!matched) {\n      ignored++;\n    }\n  });\n\n  debug('good', good)\n\n  // finally check the good files against the extensions that we're monitoring\n  if (ext) {\n    if (ext.indexOf(',') === -1) {\n      ext = '**/*.' + ext;\n    } else {\n      ext = '**/*.{' + ext + '}';\n    }\n\n    good = good.filter(function (file) {\n      // only compare the filename to the extension test\n      return minimatch(path.basename(file), ext, minimatchOpts);\n    });\n  } // else assume *.*\n\n  var result = good.concat(whitelist);\n\n  if (utils.isWindows) {\n    // fix for windows testing - I *think* this is okay to do\n    result = result.map(function (file) {\n      return file.slice(0, 1).toLowerCase() + file.slice(1);\n    });\n  }\n\n  return {\n    result: result,\n    ignored: ignored,\n    watched: watched,\n    total: files.length,\n  };\n}\n","module.exports = {\n  SIGHUP: 1,\n  SIGINT: 2,\n  SIGQUIT: 3,\n  SIGILL: 4,\n  SIGTRAP: 5,\n  SIGABRT: 6,\n  SIGBUS: 7,\n  SIGFPE: 8,\n  SIGKILL: 9,\n  SIGUSR1: 10,\n  SIGSEGV: 11,\n  SIGUSR2: 12,\n  SIGPIPE: 13,\n  SIGALRM: 14,\n  SIGTERM: 15,\n  SIGSTKFLT: 16,\n  SIGCHLD: 17,\n  SIGCONT: 18,\n  SIGSTOP: 19,\n  SIGTSTP: 20,\n  SIGTTIN: 21,\n  SIGTTOU: 22,\n  SIGURG: 23,\n  SIGXCPU: 24,\n  SIGXFSZ: 25,\n  SIGVTALRM: 26,\n  SIGPROF: 27,\n  SIGWINCH: 28,\n  SIGIO: 29,\n  SIGPWR: 30,\n  SIGSYS: 31,\n  SIGRTMIN: 35,\n}\n","var parse = require('./parse');\n\n/**\n * Converts a string to command line args, in particular\n * groups together quoted values.\n * This is a utility function to allow calling nodemon as a required\n * library, but with the CLI args passed in (instead of an object).\n *\n * @param  {String} string\n * @return {Array}\n */\nfunction stringToArgs(string) {\n  var args = [];\n\n  var parts = string.split(' ');\n  var length = parts.length;\n  var i = 0;\n  var open = false;\n  var grouped = '';\n  var lead = '';\n\n  for (; i < length; i++) {\n    lead = parts[i].substring(0, 1);\n    if (lead === '\"' || lead === '\\'') {\n      open = lead;\n      grouped = parts[i].substring(1);\n    } else if (open && parts[i].slice(-1) === open) {\n      open = false;\n      grouped += ' ' + parts[i].slice(0, -1);\n      args.push(grouped);\n    } else if (open) {\n      grouped += ' ' + parts[i];\n    } else {\n      args.push(parts[i]);\n    }\n  }\n\n  return args;\n}\n\nmodule.exports = {\n  parse: function (argv) {\n    if (typeof argv === 'string') {\n      argv = stringToArgs(argv);\n    }\n\n    return parse(argv);\n  },\n};","/*\n\nnodemon is a utility for node, and replaces the use of the executable\nnode. So the user calls `nodemon foo.js` instead.\n\nnodemon can be run in a number of ways:\n\n`nodemon` - tries to use package.json#main property to run\n`nodemon` - if no package, looks for index.js\n`nodemon app.js` - runs app.js\n`nodemon --arg app.js --apparg` - eats arg1, and runs app.js with apparg\n`nodemon --apparg` - as above, but passes apparg to package.json#main (or\n  index.js)\n`nodemon --debug app.js\n\n*/\n\nvar fs = require('fs');\nvar path = require('path');\nvar existsSync = fs.existsSync || path.existsSync;\n\nmodule.exports = parse;\n\n/**\n * Parses the command line arguments `process.argv` and returns the\n * nodemon options, the user script and the executable script.\n *\n * @param  {Array} full process arguments, including `node` leading arg\n * @return {Object} { options, script, args }\n */\nfunction parse(argv) {\n  if (typeof argv === 'string') {\n    argv = argv.split(' ');\n  }\n\n  var eat = function (i, args) {\n    if (i <= args.length) {\n      return args.splice(i + 1, 1).pop();\n    }\n  };\n\n  var args = argv.slice(2);\n  var script = null;\n  var nodemonOptions = { scriptPosition: null };\n\n  var nodemonOpt = nodemonOption.bind(null, nodemonOptions);\n  var lookForArgs = true;\n\n  // move forward through the arguments\n  for (var i = 0; i < args.length; i++) {\n    // if the argument looks like a file, then stop eating\n    if (!script) {\n      if (args[i] === '.' || existsSync(args[i])) {\n        script = args.splice(i, 1).pop();\n\n        // we capture the position of the script because we'll reinsert it in\n        // the right place in run.js:command (though I'm not sure we should even\n        // take it out of the array in the first place, but this solves passing\n        // arguments to the exec process for now).\n        nodemonOptions.scriptPosition = i;\n        i--;\n        continue;\n      }\n    }\n\n    if (lookForArgs) {\n      // respect the standard way of saying: hereafter belongs to my script\n      if (args[i] === '--') {\n        args.splice(i, 1);\n        nodemonOptions.scriptPosition = i;\n        // cycle back one argument, as we just ate this one up\n        i--;\n\n        // ignore all further nodemon arguments\n        lookForArgs = false;\n\n        // move to the next iteration\n        continue;\n      }\n\n      if (nodemonOpt(args[i], eat.bind(null, i, args)) !== false) {\n        args.splice(i, 1);\n        // cycle back one argument, as we just ate this one up\n        i--;\n      }\n    }\n  }\n\n  nodemonOptions.script = script;\n  nodemonOptions.args = args;\n\n  return nodemonOptions;\n}\n\n\n/**\n * Given an argument (ie. from process.argv), sets nodemon\n * options and can eat up the argument value\n *\n * @param {Object} options object that will be updated\n * @param {Sting} current argument from argv\n * @param {Function} the callback to eat up the next argument in argv\n * @return {Boolean} false if argument was not a nodemon arg\n */\nfunction nodemonOption(options, arg, eatNext) {\n  // line separation on purpose to help legibility\n  if (arg === '--help' || arg === '-h' || arg === '-?') {\n    var help = eatNext();\n    options.help = help ? help : true;\n  } else\n\n  if (arg === '--version' || arg === '-v') {\n    options.version = true;\n  } else\n\n  if (arg === '--no-update-notifier') {\n    options.noUpdateNotifier = true;\n  } else\n\n  if (arg === '--spawn') {\n    options.spawn = true;\n  } else\n\n  if (arg === '--dump') {\n    options.dump = true;\n  } else\n\n  if (arg === '--verbose' || arg === '-V') {\n    options.verbose = true;\n  } else\n\n  if (arg === '--legacy-watch' || arg === '-L') {\n    options.legacyWatch = true;\n  } else\n\n  if (arg === '--polling-interval' || arg === '-P') {\n    options.pollingInterval = parseInt(eatNext(), 10);\n  } else\n\n  // Depricated as this is \"on\" by default\n  if (arg === '--js') {\n    options.js = true;\n  } else\n\n  if (arg === '--quiet' || arg === '-q') {\n    options.quiet = true;\n  } else\n\n  if (arg === '--config') {\n    options.configFile = eatNext();\n  } else\n\n  if (arg === '--watch' || arg === '-w') {\n    if (!options.watch) { options.watch = []; }\n    options.watch.push(eatNext());\n  } else\n\n  if (arg === '--ignore' || arg === '-i') {\n    if (!options.ignore) { options.ignore = []; }\n    options.ignore.push(eatNext());\n  } else\n\n  if (arg === '--exitcrash') {\n    options.exitcrash = true;\n  } else\n\n  if (arg === '--delay' || arg === '-d') {\n    options.delay = parseDelay(eatNext());\n  } else\n\n  if (arg === '--exec' || arg === '-x') {\n    options.exec = eatNext();\n  } else\n\n  if (arg === '--no-stdin' || arg === '-I') {\n    options.stdin = false;\n  } else\n\n  if (arg === '--on-change-only' || arg === '-C') {\n    options.runOnChangeOnly = true;\n  } else\n\n  if (arg === '--ext' || arg === '-e') {\n    options.ext = eatNext();\n  } else\n\n  if (arg === '--no-colours' || arg === '--no-colors') {\n    options.colours = false;\n  } else\n\n  if (arg === '--signal' || arg === '-s') {\n    options.signal = eatNext();\n  } else\n\n  if (arg === '--cwd') {\n    options.cwd = eatNext();\n\n    // go ahead and change directory. This is primarily for nodemon tools like\n    // grunt-nodemon - we're doing this early because it will affect where the\n    // user script is searched for.\n    process.chdir(path.resolve(options.cwd));\n  } else {\n\n    // this means we didn't match\n    return false;\n  }\n}\n\n/**\n * Given an argument (ie. from nodemonOption()), will parse and return the\n * equivalent millisecond value or 0 if the argument cannot be parsed\n *\n * @param {String} argument value given to the --delay option\n * @return {Number} millisecond equivalent of the argument\n */\nfunction parseDelay(value) {\n  var millisPerSecond = 1000;\n  var millis = 0;\n\n  if (value.match(/^\\d*ms$/)) {\n    // Explicitly parse for milliseconds when using ms time specifier\n    millis = parseInt(value, 10);\n  } else {\n    // Otherwise, parse for seconds, with or without time specifier then convert\n    millis = parseFloat(value) * millisPerSecond;\n  }\n\n  return isNaN(millis) ? 0 : millis;\n}\n\n","var fs = require('fs');\nvar path = require('path');\nconst supportsColor = require('supports-color');\n\nmodule.exports = help;\n\nconst highlight = supportsColor.stdout ? '\\x1B\\[$1m' : '';\n\nfunction help(item) {\n  if (!item) {\n    item = 'help';\n  } else if (item === true) { // if used with -h or --help and no args\n    item = 'help';\n  }\n\n  // cleanse the filename to only contain letters\n  // aka: /\\W/g but figured this was eaiser to read\n  item = item.replace(/[^a-z]/gi, '');\n\n  try {\n    var dir = path.join(__dirname, '..', '..', 'doc', 'cli', item + '.txt');\n    var body = fs.readFileSync(dir, 'utf8');\n    return body.replace(/\\\\x1B\\[(.)m/g, highlight);\n  } catch (e) {\n    return '\"' + item + '\" help can\\'t be found';\n  }\n}\n","const utils = require('./utils');\nconst merge = utils.merge;\nconst bus = utils.bus;\nconst spawn = require('child_process').spawn;\n\nmodule.exports = function spawnCommand(command, config, eventArgs) {\n  var stdio = ['pipe', 'pipe', 'pipe'];\n\n  if (config.options.stdout) {\n    stdio = ['pipe', process.stdout, process.stderr];\n  }\n\n  var sh = 'sh';\n  var shFlag = '-c';\n\n  if (utils.isWindows) {\n    sh = 'cmd';\n    shFlag = '/c';\n  }\n\n\n  if (!Array.isArray(command)) {\n    command = [command];\n  }\n\n  const args = command.join(' ');\n\n  const env = merge(process.env, { FILENAME: eventArgs[0] });\n  const child = spawn(sh, [shFlag, args], {\n    env: merge(config.options.execOptions.env, env),\n    stdio: stdio,\n  });\n\n  if (config.required) {\n    var emit = {\n      stdout: function (data) {\n        bus.emit('stdout', data);\n      },\n      stderr: function (data) {\n        bus.emit('stderr', data);\n      },\n    };\n\n    // now work out what to bind to...\n    if (config.options.stdout) {\n      child.on('stdout', emit.stdout).on('stderr', emit.stderr);\n    } else {\n      child.stdout.on('data', emit.stdout);\n      child.stderr.on('data', emit.stderr);\n\n      bus.stdout = child.stdout;\n      bus.stderr = child.stderr;\n    }\n  }\n};\n"]}